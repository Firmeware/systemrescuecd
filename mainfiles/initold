#!/bin/sh
# Copyright 2003-2006 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2

good_msg()
{
	msg_string=$1
	msg_string="${msg_string:-...}"
	#[ "$2" != 1 ] && echo -e "${GOOD}>>${NORMAL}${BOLD} ${msg_string} ${NORMAL}"
	[ "$2" != 1 ] && echo -e "${GOOD}>>${NORMAL} ${msg_string} ${NORMAL}"
}

bad_msg()
{
	msg_string=$1
	msg_string="${msg_string:-...}"
	#if [ "$2" != 1 ] && echo -e "${BAD}!!${NORMAL}${BOLD} ${msg_string} ${NORMAL}"
	[ "$2" != 1 ] && echo -e "${BAD}!!${NORMAL} ${msg_string} ${NORMAL}"
}

parse_opt()
{
	case "$1" in
		*\=*)
		local key_name="`echo "$1" | cut -f1 -d=`"
		local key_len=${#key_name}
		local value_start=$((key_len+2))
		echo "$1" | cut -c ${value_start}-
		;;
	esac
}

sysresccd_expand()
{
	for curdev in $*
	do
		echo ${curdev}
	done
}

sysresccd_expand_removable()
{
	# Look for the value of 1 in the file /sys/block/sd*/removable
	for curdev in $*
	do
		devroot=$(echo ${curdev} | busybox awk -F / '{sub(/[0-9]+$/,"",$NF); print $NF}')
		removable_f="/sys/block/${devroot}/removable"
		[ -f "${removable_f}" ] && grep -q ^1 ${removable_f} && echo ${curdev}
	done
}

sysresccd_runshell()
{
	if [ -n "$1" ] && [ -x "$1" ]
	then
		exec "$1"
	else
		exec /bin/sh
	fi
	exit 1
}

sysresccd_panic()
{
	bad_msg "$@"
	bad_msg "Running a mini shell (cannot complete the boot process)"
	sleep 2
	sysresccd_runshell
}

ask_netboot_url()
{
	url="$1"
	echo "You requested a network boot, the ${LOOPDAT} image will be loaded " 1>&2
	echo "through HTTP or TFTP. You have to provide the URL of the ${LOOPDAT} file " 1>&2
	echo "to boot from. (eg: \"http://192.168.1.5/${LOOPDAT}\" or \"tftp://192.168.1.5/${LOOPDAT}\"): " 1>&2
	echo "> " 1>&2
	while ! echo "${url}" | grep -q -E '^http://|^tftp://'
	do
		[ "${url}" != 'ask' ] && echo "Invalid http/tftp url (${url})" 1>&2
		read -p "<< URL of the ${LOOPDAT} to boot from:> " url
	done
	echo "${url}"
}

is_valid_bootnet_url()
{
	echo "${1}" | grep -q '^http://' && return 0
	echo "${1}" | grep -q '^tftp://' && return 0
	return 1
}

sysresccd_bootstrap_net()
{
	mkdir -p /cdrom # where the downloaded files are copied (docache)
	if ! mount -t tmpfs -o ${CACHESIZE} tmpfs /cdrom
	then
		sysresccd_panic "Cannot create tmpfs on /cdrom"
	fi

	# if no static ip address configured from the command line --> run dhcp client
	if [ "${NETBOOT}" = 'ask' ]
	then
		NETBOOT="$(ask_netboot_url ${NETBOOT} )"
	fi

	if ! is_valid_bootnet_url "${NETBOOT}"
	then
		echo "You requested a network boot, the netboot address is not a valid http:// or tftp:// url."
		NETBOOT="$(ask_netboot_url ${NETBOOT} )"
	fi

	good_msg "Downloading ${LOOPDAT} from ${NETBOOT}"
	if echo "${NETBOOT}" | grep -q '^http://'
	then
		REAL_ROOT="http"
		BOOTMD5=$(echo ${NETBOOT} | sed -e "s/${LOOPDAT}/${LOOPMD5}/g") # URL of the md5 file
		/bin/busybox wget ${BOOTMD5} -O /cdrom/${LOOPMD5}
		res1="$?"
		/bin/busybox wget ${NETBOOT} -O /cdrom/${LOOPDAT}
		res2="$?"
	elif echo "${NETBOOT}" | grep -q '^tftp://'
	then
		REAL_ROOT="tftp"
		url="$(echo ${NETBOOT} | sed 's!tftp://!!g')" # remote the 'tftp://' prefix
		tftpip="${url%%/*}"
		tftpurl="/${url#*/}"
		BOOTMD5=$(echo ${tftpurl} | sed -e "s/${LOOPDAT}/${LOOPMD5}/g") # URL of the md5 file
		cmd1="/bin/busybox tftp -g -r ${BOOTMD5} -l /cdrom/${LOOPMD5} ${tftpip}"
		echo "$cmd1"
		${cmd1} ; res1="$?"
		cmd2="/bin/busybox tftp -g -r ${tftpurl} -l /cdrom/${LOOPDAT} ${tftpip}"
		echo "$cmd2"
		${cmd2} ; res2="$?"
	fi

	if [ "$res1" != '0' ] || [ "$res2" != '0' ]
	then
		sysresccd_panic "Cannot download the files, wget/tftp failed. May be due to lack of memory"
	fi

	if [ ! -f "/cdrom/${LOOPDAT}" ]
	then
		sysresccd_panic "Cannot download the \"${LOOPDAT}\" boot file."
	fi

	md5now=$(busybox md5sum /cdrom/${LOOPDAT} | cut -d ' ' -f1)
	md5orig=$(cat /cdrom/${LOOPMD5} | cut -d ' ' -f1)
	if [ "$md5now" = "$md5orig" ]
	then
		good_msg "Downloaded boot file to \"/cdrom/${LOOPDAT}\""
		DOCHECK=0 # Do not check the md5sum again in the general code (before mount squashfs)
	else
		sysresccd_panic "The root filesystem image is invalid: md5sum failed"
	fi
}

sysresccd_bootstrap_nfs()
{
	REAL_ROOT="nfs"
	mkdir -p /cdrom

	good_msg "Mouting the NFS filesystem..."
	if ! mount -t nfs -o intr,nolock ${NFSBOOT} /cdrom
	then
		sysresccd_panic "Cannot mount nfs share on /cdrom"
	fi
	good_msg "Successfully mounted the NFS filesystem"

	if [ ! -f "/cdrom/${SUBDIR}/${LOOPDAT}" ]
	then
		sysresccd_panic "Cannot find the \"${SUBDIR}/${LOOPDAT}\" boot file."
	fi

	md5now=$(busybox md5sum /cdrom/${SUBDIR}/${LOOPDAT} | cut -d ' ' -f1)
	md5orig=$(cat /cdrom/${SUBDIR}/${LOOPMD5} | cut -d ' ' -f1)
	if [ "$md5now" = "$md5orig" ]
	then
		DOCHECK=0 # Do not check the md5sum again in the general code (before mount squashfs)
	else
		sysresccd_panic "md5sum checksum is invalid on the root filesystem image"
	fi
}

sysresccd_bootstrap_nbd()
{
	REAL_ROOT="nbd"
	NBD_DEVICE="/dev/nbd0"
	NBD_PROG="/sbin/nbd-client"

	NBD_SERVER=$(echo "${NBDBOOT}" | sed 's/:.*//')
	NBD_PORT=$(echo "${NBDBOOT}" | sed 's/.*://')

	if [ ! -x "${NBD_PROG}" ]
	then
		sysresccd_panic "Error: program ${NBD_PROG} not found"
	fi

	if ! modprobe nbd
	then
		sysresccd_panic "Error: cannot load nbd kernel module"
	fi
	#mknod /dev/nbd0 b 43 0
	good_msg "Setting up the NBD boot device..."
	if ! ${NBD_PROG} "${NBD_SERVER}" "${NBD_PORT}" "${NBD_DEVICE}" -persist
	then
		sysresccd_panic "Error: nbd-client failed to connect to ${NBD_SERVER}:${NBD_PORT}"
	else
		good_msg "nbd-client successfully connected to ${NBD_SERVER}:${NBD_PORT}"
	fi
}

sysresccd_findcdmount()
{
	REAL_ROOT=''
	[ -n "${CDROOT_DEV}" ] && BLKDEVICES="$BLKDEVICES ${CDROOT_DEV}"
	mkdir -p /cdrom

	for curdev in $(sysresccd_expand ${BLKDEVICES})
	do
		# Check for a block device to mount
		if [ -b "${curdev}" ] && [ -z "${REAL_ROOT}" ]
		then
			# check the 'skipmount=/dev/xxx' option (use it with a failing hard drive)
			# compare with a space at the end so that "/dev/sda1" and "/dev/sda11" don't match
			if echo "$(cat /proc/cmdline) " | grep -F -q "skipmount=${curdev} "
			then
				good_msg "Skipping mount on device :- ${curdev}"
			else
				good_msg "Attempting to mount media:- ${curdev}"

				for curfs in vfat msdos iso9660 ntfs auto
				do
					case "${curfs}" in
						iso9660)
							mntopt='-o mode=0644'
							;;
						vfat)
							mntopt='-o fmask=0133'
							;;
						*)
							mntopt=''
							;;
					esac

					mount -r -t $curfs ${curdev} /cdrom ${mntopt} >/dev/null 2>&1
					if [ "$?" = '0' ]
					then
						if [ -e /cdrom/${SUBDIR}/${LOOPDAT} ]
						then
							REAL_ROOT="${curdev}"
							ROOTFS="${curfs}"
							good_msg "Media found on ${curdev}"
						else
							umount /cdrom
						fi
					fi
				done
			fi
		fi
	done
	if [ -z "${REAL_ROOT}" ]
	then
		bad_msg "Media not found"
	fi
}

sysresccd_findisomount()
{
    REAL_ROOT=''
    [ -n "${CDROOT_DEV}" ] && BLKDEVICES="$BLKDEVICES ${CDROOT_DEV}"
    mkdir -p /cdrom /isostore
    for curdev in $(sysresccd_expand ${BLKDEVICES})
    do
        # Check for a block device to mount
        if [ -b "${curdev}" ] && [ -z "${REAL_ROOT}" ]
        then
            # check the 'skipmount=/dev/xxx' option (use it with a failing hard drive)
            # compare with a space at the end so that "/dev/sda1" and "/dev/sda11" don't match
            if echo "$(cat /proc/cmdline) " | grep -F -q "skipmount=${curdev} "
            then
                good_msg "Skipping mount on device :- ${curdev}"
            else
                good_msg "Attempting to find the iso on ${curdev}"
                for curfs in vfat msdos ntfs auto
                do
                    case "${curfs}" in
                        vfat)
                            mntopt='-o fmask=0133'
                            ;;
                        *)
                            mntopt=''
                            ;;
                    esac
                    if mount -r -t $curfs ${curdev} /isostore ${mntopt} >/dev/null 2>&1
                    then
                        if [ -e "/isostore/${SUBDIR}/${ISOLOOP}" ]
                        then
                            ISOLOOPDEV="${curdev}"
                            good_msg "iso image found on ${curdev}"
                            if mount -r -t iso9660 -o loop "/isostore/${SUBDIR}/${ISOLOOP}" /cdrom >/dev/null 2>&1
                            then
                                if [ -e /cdrom/${SUBDIR}/${LOOPDAT} ]
                                then
                                    REAL_ROOT="iso"
                                    good_msg "Media found on /isostore/${SUBDIR}/${ISOLOOP}"
                                else
                                    umount /cdrom
                                    umount /isostore
                                fi
                            fi
                        else
                            umount /isostore
                        fi
                    fi
                    mount -r -t $curfs ${curdev} /cdrom ${mntopt} >/dev/null 2>&1
                    if [ "$?" = '0' ]
                    then
                        if [ -e /cdrom/${SUBDIR}/${LOOPDAT} ]
                        then
                            REAL_ROOT="${curdev}"
                            ROOTFS="${curfs}"
                            good_msg "Media found on ${curdev}"
                        else
                            umount /cdrom
                        fi
                    fi
                done
            fi
        fi
    done
    if [ -z "${REAL_ROOT}" ]
    then
        bad_msg "Media not found"
    fi
}

sysresccd_cache_cd_contents()
{
	# Check loop file exists and cache to ramdisk if DOCACHE is enabled
	if [ -z "${LOOPDAT}" -o ! -e "/cdrom/${SUBDIR}/${LOOPDAT}" ]
	then
		sysresccd_panic "Invalid loop location: ${LOOPDAT}"
	fi

	if [ "${DOCACHE}" = '1' ]
	then
		good_msg "Creating tmpfs for caching"
		mkdir -p /cache # where the cached files are copied (docache)
		if ! mount -t tmpfs -o ${CACHESIZE} tmpfs /cache
		then
			sysresccd_panic "Cannot create tmpfs on /cache"
		fi

		# --------------- Get loopfile size
		squashfspath="/cdrom/${SUBDIR}/${LOOPDAT}"
		squashfssize=$(ls -l "$squashfspath" | sed -e ":a;s/  / /g;ta" | cut -f 5 -d ' ') # size in bytes
		squashfssizekb=$(( $squashfssize / 1024 )) # size in kilo-bytes

		# --------------- Cache autorun files
		autoruns="$(ls -d /cdrom/${SUBDIR}/autorun* 2>/dev/null)"
		[ "$autoruns" != "" ] && cp $autoruns /cache/

		# --------------- Cache main loop file
		cp -a /cdrom/${SUBDIR}/version /cache/ 2>/dev/null
		cp -a /cdrom/${SUBDIR}/${LOOPMD5} /cache/${LOOPMD5} 2>/dev/null
		good_msg "Copying ${LOOPDAT} file for caching (size: $squashfssizekb KB)..."
		cp -a /cdrom/${SUBDIR}/${LOOPDAT} /cache/${LOOPDAT} 2>/dev/null

		# --------------- Check main loop file
		expectedsize=$(busybox stat -c%s "/cdrom/${SUBDIR}/${LOOPDAT}")
		copiedsize=$(busybox stat -c%s "/cache/${LOOPDAT}")
		#echo "expectedsize=[${expectedsize}] and copiedsize=[${copiedsize}]"

		if [ "$copiedsize" != "$expectedsize" ] # Was the copy completed successfully ?
		then # docache failed
			bad_msg "Caching failed. Likely due to lack of memory"
			rm -f "/cache/${LOOPDAT}"
			umount /cache 2>/dev/null
			sleep 5
		else # docache successful
			good_msg "Caching ${LOOPDAT} successful"
			SUBDIR=''

			# --------------- Cache other files if possible
			if [ -d /cdrom/${SUBDIR}/isolinux ] && [ -d /cdrom/${SUBDIR}/bootdisk ] && [ -d /cdrom/${SUBDIR}/ntpasswd ] && [ "${LOWMEM}" = '0' ]
			then
				good_msg "Copying isolinux and bootdisk for caching..."
				if ! cp -a /cdrom/${SUBDIR}/isolinux /cdrom/${SUBDIR}/bootdisk /cdrom/${SUBDIR}/ntpasswd /cache/ 2>/dev/null
				then
					rm -rf /cache/{isolinux,bootdisk,ntpasswd}
					bad_msg "Cannot cache isolinux and bootdisk (required for PXE-server). Likely due to lack of memory"
				fi
			fi

			# --------------- Unmount the cdrom if possible
			if umount /cdrom/
			then
				good_msg "Unmounted the cdrom."
				cmd="mount -n --move /cache /cdrom"
				if ! ${cmd}
				then
					echo "${cmd} --> ${res}" && sleep 3
				fi
			else
				bad_msg "Cannot unmount the cdrom."
			fi
		fi
	fi
}

sysresccd_setup_keymap()
{
	if [ -z "$SETKMAP" ]
	then
		if [ ! -e /dev/vc/0 -a ! -e /dev/tty0 ]
		then
			DEVBIND=1
			mount -o bind ${NEW_ROOT}/dev /dev
		fi
		[ ! -e /dev/tty0 ] && ln -s /dev/tty1 /dev/tty0

		sysresccd_chooseKeymap

		[ "${DEVBIND}" -eq '1' ] && umount /dev
	else # "setkmap=xx" option was used
		sysresccd_useKeymap $SETKMAP
	fi
}

sysresccd_useKeymap()
{
	keymap=$1

	if [ -e /lib/keymaps/${keymap}.map ]
	then
		good_msg "Loading the ''${keymap}'' keymap"
		loadkmap < /lib/keymaps/${keymap}.map
		xkeymap=${keymap}
		echo ${keymap} | grep -e "[0-9]+" >/dev/null 2>&1
		if [ "$?" -eq '0'  ]
		then
			xkeymap=`tail -n 7 /lib/keymaps/keymapList | grep ${keymap} | sed -r "s/.*\s+${keymap}\s+([a-z-]+).*/\1/g" | grep -v 1`
		fi
		mkdir -p /etc/sysconfig
		echo "XKEYBOARD=${xkeymap}" > /etc/sysconfig/keyboard
	elif [ "$keymap" = '' ]
	then
		echo
		good_msg "Keeping default keymap"
	else
		bad_msg "Sorry, but keymap ''${keymap}'' is invalid!"
		sysresccd_chooseKeymap
	fi
}

sysresccd_chooseKeymap()
{
	good_msg "Loading keymaps"
	cat /lib/keymaps/keymapList
	echo "default choice (US keymap) will be used if no action within 20 seconds"
	read -t 20 -p '<< Load keymap (Enter for default): ' keymap
	sysresccd_useKeymap $keymap
}

# ---- convert a short netmask (eg: '/24') to a long one ----
netmask_shorttolong() # eg: '24' ==> '255.255.255.0'
{
	mask="$1"
	if [ -n "${mask}" ]
	then
		[ "${mask}" -gt '32' ] && mask='32'
		[ "${mask}" -lt '0' ] && mask='0'
		bit=0
		for i in 0 1 2 3
		do
			curbyte=0
			for j in 0 1 2 3 4 5 6 7
			do
				curbit=0 ; [ "$bit" -lt "$mask" ] && curbit=1
				curbyte=$((curbyte*2))
				curbyte=$((curbyte+curbit))
				bit=$((bit+1))
			done
			echo -n "$curbyte"
			[ "$i" -lt '3' ] && echo -n '.'
		done
	fi
}

# configure an interface: eg: $1='192.168.1.1/24' $2='eth0'
netconfig_setip()
{
	ethip=$1
	cureth=$2
	ipaddrbase=${ethip%%/*} # '192.168.1.1/24' --> '192.168.1.1'

	if echo "${ethip}" | grep -q -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/([0-9]{1,2})$'
	then
		ipaddrmask=${ethip#*/} # '192.168.1.1/24' --> '24'
	else
		ipaddrmask=''
	fi

	if [ -n "${ipaddrmask}" ]
	then
		iplongmask=$(netmask_shorttolong $ipaddrmask  2>/dev/null)
		maskopt="netmask ${iplongmask}"
		echo "netconfig1: netmask_shorttolong($ipaddrmask)=$iplongmask"
	else
		iplongmask=''
		maskopt=''
	fi

	echo "netconfig1: configure ${cureth} to ${ethip}"
	ipcmd_add="ifconfig ${cureth} ${ipaddrbase} ${maskopt}"
	${ipcmd_add} ; res=$?
	echo "netconfig1: ${ipcmd_add} --> ${res}"
}

sysresccd_speakup()
{
	if [ -n "${SPEAKUP}" ]
	then
		OPTLIST="$(echo ${SPEAKUP} | sed -e 's!,! !g')"

		for curopt in ${OPTLIST}
		do
			for x in ${curopt}
			do
				case "${x}" in
					quiet\=*)
						SPEAKUP_QUIET=`parse_opt "${x}"`
						;;
					synth\=*)
						SPEAKUP_SYNTH=`parse_opt "${x}"`
						;;
					port\=*)
						SPEAKUP_PORT=`parse_opt "${x}"`
						SPEAKUP_OPTIONS="${SPEAKUP_OPTIONS} port=${SPEAKUP_PORT}"
						;;
					ser\=*)
						SPEAKUP_SER=`parse_opt "${x}"`
						SPEAKUP_OPTIONS="${SPEAKUP_OPTIONS} ser=${SPEAKUP_SER}"
						;;
				esac
			done
		done

		if [ -n "${SPEAKUP_QUIET}" ]
		then
			cmd="modprobe speakup quiet=${SPEAKUP_QUIET}"
			${cmd}
		fi

		if [ -n "${SPEAKUP_SYNTH}" ]
		then
			cmd="modprobe speakup_${SPEAKUP_SYNTH} ${SPEAKUP_OPTIONS} start=1"
			${cmd}
		fi
	fi
}

sysresccd_udev_start()
{
	good_msg "Loading modules..."

	echo '0' > /proc/sys/kernel/printk

	# Note that this only becomes /dev on the real filesystem if udev's scripts
	# are used; which they will be, but it's worth pointing out
	tmpfs_size="10M"
	if [ -e /etc/udev/udev.conf ]; then
		. /etc/udev/udev.conf
	fi
	mount -t tmpfs -o size=$tmpfs_size,mode=0755 udev /dev
	[ -e /dev/console ] || mknod -m 0600 /dev/console c 5 1
	[ -e /dev/null ] || mknod /dev/null c 1 3
	> /dev/.initramfs-tools
	mkdir /dev/.initramfs

	# Set modprobe env
	export MODPROBE_OPTIONS="-qb"

	# delete the useless modules
	ls /lib/modules | grep -v $(uname -r) | busybox xargs rm -rf

	# process module dependencies
	depmod -a

	# load custom modules
	for modname in ${MODLOAD}
	do
		echo "OPTION doload=${modname} ==> loading module ${modname}"
		modprobe ${modname}
		if [ $? -eq 0 ] ; then
			good_msg "modprobe ${modname} successful"
		else
			bad_msg "modprobe ${modname} failed (res=$?)"
		fi
	done

	# write blacklist to modprobe.d
	for modname in ${BLACKLIST}
	do
		echo "OPTION noload=${modname} ==> excluding module ${modname}"
		echo "blacklist ${modname}" >> /etc/modprobe.d/initramfs
	done

	# run udevd and let it process uevents
	echo > /sys/kernel/uevent_helper
	mkdir -p /dev/.udev/db/
	udevd --daemon --resolve-names=never
	mkdir -p /dev/.udev/queue/ /dev/.udev/rules.d/
	udevadm trigger
	udevadm settle || true

	# if the scandelay parameter has been set, we wait a bit for devices
	sleep 3 # sleep 3 seconds anyway: most USB devices just need it to initialize
	[ -n "${SCANDELAY}" ] && good_msg "Waiting ${SCANDELAY} seconds..." && sleep ${SCANDELAY}

	good_msg 'Modules loaded'
	cat /proc/modules
}

sysresccd_udev_stop()
{
	# Stop udevd, we'll miss a few events while we run init, but we catch up
	for proc in /proc/[0-9]*
	do
		[ -x $proc/exe ] || continue
		[ "$(busybox readlink $proc/exe)" != /sbin/udevd ] || kill ${proc#/proc/}
	done
	echo '6' > /proc/sys/kernel/printk
}

sysresccd_netconfig()
{
	good_msg "Performing the network configuration..."

	# ---- force dhcp if booting via pxe and no static configuration specified
	if [ -n "${NETBOOT}" ] || [ -n "${NFSBOOT}" ] || [ -n "${NBDBOOT}" ]
	then
		if ! cat /proc/cmdline | grep -q -E 'eth[x0-9]{1,2}=[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
		then
			DODHCP='1'
		fi
	fi

	# ---- create the /etc/nsswitch.conf file (it must exist for both dns and static) ----
	rm -f /etc/nsswitch.conf /etc/host.conf
	echo "hosts: files dns" > /etc/nsswitch.conf

	# ---- set the name of the network interfaces if requested on the boot argv
	if grep -q -E 'nameif=[0-9,!:a-fA-F]*' /proc/cmdline
	then
		good_msg "Renaming the network interfaces (option 'nameif' was used)"
		ethlist="$(/sbin/ifconfig -a | grep 'HWaddr' | grep '^eth[0-9]*' | busybox awk '{print $1}')"
		maclist="$(/sbin/ifconfig -a | grep 'HWaddr' | grep '^eth[0-9]*' | busybox awk '{print $5}')"

		# ---- get the option from the boot command line # eg: "nameif=eth0!00:11:22:33:44:55,eth1!00:22:33:44:55:aa"
		NAMEIFOPT=''
		for x in $(cat /proc/cmdline)
		do
			if echo "${x}" | grep -q -E 'nameif=[0-9,!:a-fA-F]*'
			then
				NAMEIFOPT="$(echo ${x} | cut -d= -f2 | sed -e 's!,! !g')"
			fi
		done

		# ---- rename all the network interfaces so that each name is free for another interface
		pos=0
		for curmac in ${maclist}
		do
			cmd="busybox nameif iftmp${pos} ${curmac}"
			${cmd}
			echo "netconfig1: ${cmd} --> $?"
			pos=$((pos+1))
		done

		# ---- rename the interfaces with the name requested on the boot command
		for val in ${NAMEIFOPT}
		do
			for opt in ${val}
			do
				name="$(echo ${opt} | cut -d! -f1)"
				mac="$(echo ${opt} | cut -d! -f2)"

				cmd="busybox nameif $name $mac"
				${cmd}
				echo "netconfig1: ${cmd} --> $?"
				sleep 1
			done
		done

		# ---- attribute the remaining names to the remaining network interfaces
		maclist="$(/sbin/ifconfig -a | grep 'HWaddr' | grep '^iftmp[0-9]*' | busybox awk '{print $5}')"
		for curmac in ${maclist}
		do
			pos=0
			ifdone=0
			while [ "${pos}" -lt 99 ] && [ "$ifdone" = '0' ]
			do
				curif="eth${pos}"
				if ! /sbin/ifconfig -a | grep 'HWaddr' | grep -q "^${curif}"
				then
					cmd="busybox nameif $curif $curmac"
					${cmd}
					echo "netconfig1: ${cmd} --> $?"
					ifdone=1
					sleep 1
				fi
				pos=$((pos+1))
			done
		done
	fi

	if [ "${LOADNET}" = '1' ] # show interfaces detected with the new name
	then
		ethlist="$(/sbin/ifconfig -a | grep 'HWaddr' | grep '^eth[0-9]*' | busybox awk '{print $1}')"

		if [ -z "${ethlist}" ]
		then
			echo "No ethernet interfaces found on your system, PXE boot won't work."
			sleep 2
		else
			echo "Here are the ethernet interfaces found on your system:"

			# ---- get the option from the boot command line # eg: "nameif=eth0!00:11:22:33:44:55,eth1!00:22:33:44:55:aa"
			for cureth in ${ethlist}
			do
				#cureth="${ethlist[curpos]}"
				curmac="$(/sbin/ifconfig ${cureth} | grep 'HWaddr' | grep '^eth[0-9]*' | busybox awk '{print $5}')"
				echo "* ${cureth}: ${curmac}"
				ifconfig ${cureth} up
			done
		fi
	fi

	# ---- configure the ethernet interfaces if requested by 'ethx=ip' ----
	if [ -n "${SETETHX}" ]
	then
		echo "netconfig1: found option ethx=${SETETHX}"
		ethlist="$(/sbin/ifconfig -a | grep 'eth' | busybox awk '{print $1}' | busybox xargs)" # (eg: eth0 eth1 eth2)
		for cureth in ${ethlist}
		do
			netconfig_setip ${SETETHX} ${cureth}
		done
	fi

	# =======================================================================================

	# ---- configure individual ethernet interfaces ----
	if cat /proc/cmdline | grep -q -E 'eth[0-9]{1,2}=[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
	then
		# parse the command line for individual ethernet interfaces settings
		for x in $(cat /proc/cmdline)
		do
			if echo "${x}" | grep -q -E 'eth[0-9]{1,2}=[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
			then
				iface=$(echo ${x} | cut -d= -f1)
				ipaddr=$(echo ${x} | cut -d= -f2)
				echo "netconfig1: found option ${x}"
				netconfig_setip ${ipaddr} ${iface}
			fi
		done
	fi

	# ---- configure the network via dhcp ----
	if [ -n "${DODHCP}" ]
	then
		ethlist="$(/sbin/ifconfig -a | grep 'eth' | busybox awk '{print $1}' | busybox xargs)" # (eg: eth0 eth1 eth2)

		dhcpstate=''
		while [ "${dhcpstate}" != 'ok' ] # retry until we get a dhcp address on at least one interface
		do
			for cureth in ${ethlist}
			do
				# Try to find whether or not the link is connected
				mac=$(ifconfig ${cureth} | grep HWaddr | busybox awk '{print $5}')
				if [ -f /sbin/mii-tool ] && /sbin/mii-tool ${cureth} 2>/dev/null | grep -qF 'link ok'
				then
					linkstate='link-ok'
				elif [ -f /sbin/mii-tool ] && /sbin/mii-tool ${cureth} 2>/dev/null | grep -qF 'no link'
				then
					linkstate='no-link'
				else # if not sure, set linkstate='unknown'
					linkstate='unknown'
				fi
				echo "--- ${cureth}: link=${linkstate}, mac=${mac}"

				# If the link is up, then try (even if another interface already has a dhcp address)
				if [ "${linkstate}" != 'no-link' ] 
				then
					good_msg "Attempting to get a DHCP address on ${cureth}..."
					[ -n "${DHCPHOSTNAME}" ] && hostnameopt="-H ${DHCPHOSTNAME}"
					cmd="busybox udhcpc -n -i ${cureth} ${hostnameopt}"
					${cmd} ; res="$?"
					echo "${cmd} --> ${res}"
					[ "${res}" = '0' ] && dhcpstate='ok'
				fi
			done

			if [ "${dhcpstate}" != 'ok' ]
			then
				echo "Cannot get a DHCP address. Check the cables on the ethernet interfaces."
				sleep 2
			fi
		done
	fi

	# ---- configure the gateway if requested on cmdline ----
	if [ -n "${SETGW}" ]
	then
		while route del default gw 0.0.0.0 2>&-
		do
			echo "netconfig1: removing old default route"
		done
		echo "netconfig1: set new default route to ${SETGW}"
		route add default gw ${SETGW}
	fi

	# ---- configure the nameserver if requested on cmdline ----
	if [ -n "${SETDNS}" ]
	then
		rm -f /etc/resolv.conf 2>/dev/null
		echo "netconfig1: set nameserver to ${SETDNS}"
		echo "nameserver ${SETDNS}" > /etc/resolv.conf
	fi
}

# =============================================================================
# =============================================================================

NORMAL="\033[0m"
WARN="\033[33;1m"
BAD="\033[31;1m"
BOLD="\033[1m"
GOOD="\033[32;1m"

CACHESIZE='size=512m'
CDROOT='1'
DOCACHE=''
REAL_ROOT=''
SETKMAP=''
MINISHELL=''
FAKE_ROOT='/dev/ram0'
LOOPDAT='sysrcd.dat'
LOOPMD5='sysrcd.md5'
BACKSTORECMD=''
DHCPHOSTNAME=''
DOCHECK='0'
LOWMEM='0'
LOADNET=''
BOOTHD=''
SETGW=''
SETDNS=''
SETETHX=''
NETBOOT=''
NFSBOOT=''
NBDBOOT=''
ISOLOOP=''
ISOLOOPDEV=''
DODHCP=''
ROOTFS=''
SUBDIR=''
SPEAKUP=''

REAL_ROOT=''
CDROOT_DEV=''
NEW_ROOT='/newroot'
INITPROG='/sbin/init'
CONSOLE='/dev/console'

# CDROM DEVICES
BLKDEVICES="/dev/cdroms/* /dev/ide/cd/* /dev/sr*"
# USB Keychain/Storage
BLKDEVICES="$BLKDEVICES /dev/sd*"
# IDE devices
BLKDEVICES="$BLKDEVICES /dev/hd*"
# USB using the USB Block Driver
BLKDEVICES="$BLKDEVICES /dev/ubd* /dev/ubd/*"
# iSeries devices
BLKDEVICES="$BLKDEVICES /dev/iseries/vcd*"
# HP Smart Array
BLKDEVICES="$BLKDEVICES /dev/cciss* /dev/cciss/*"
# dmraid
BLKDEVICES="$BLKDEVICES /dev/dm* /dev/mapper/asr* /dev/mapper/ddf1* /dev/mapper/hpt*"
BLKDEVICES="$BLKDEVICES /dev/mapper/isw* /dev/mapper/jmicron* /dev/mapper/lsi*"
BLKDEVICES="$BLKDEVICES /dev/mapper/nvidia* /dev/mapper/pdc* /dev/mapper/sil*"
BLKDEVICES="$BLKDEVICES /dev/mapper/via* /dev/mapper/dos*"

# Removable devices only
REMOVABLE_BLKDEVICES="/dev/sd?[1-9] /dev/sd?[1-9][0-9] /dev/ubd?[1-9] /dev/ubd?[1-9][0-9]"

# =============================================================================
# =============================================================================

if [ "$$" != '1' ]
then
	echo '/linuxrc has to be run as the init process as the one'
	echo 'with a PID of 1. Try adding init="/linuxrc" to the'
	echo 'kernel command line or running "exec /linuxrc".'
	exit 1
fi

# create system directories
[ -d /dev ] || mkdir -m 0755 /dev
[ -d /root ] || mkdir -m 0700 /root
[ -d /sys ] || mkdir /sys
[ -d /proc ] || mkdir /proc
[ -d /tmp ] || mkdir /tmp
[ -d /selinux ] || mkdir /selinux
mkdir -p /var/lock

# mount virtual filesystems
export PATH=/bin:/usr/bin:/sbin:/usr/sbin
/bin/busybox mkdir -p /usr/bin /usr/sbin
/bin/busybox mount -t sysfs -o nodev,noexec,nosuid none /sys
/bin/busybox mount -t proc -o nodev,noexec,nosuid none /proc

# Set up busybox
/bin/busybox --install -s

# =============================================================================
# =============================================================================

for x in $(cat /proc/cmdline)
do
	case "${x}" in
		real_root\=*)
			REAL_ROOT=`parse_opt "${x}"`
		;;
		root\=*)
			FAKE_ROOT=`parse_opt "${x}"`
			CDROOT=0
		;;
		init\=*)
			INITPROG=`parse_opt "${x}"`
		;;
		docache)
			DOCACHE=1
		;;
		ethx\=*)
			SETETHX=`parse_opt "${x}"`
			DODHCP=''
			LOADNET='1'
		;;
		dodhcp)
			DODHCP='1'
			SETETHX=''
			LOADNET='1'
		;;
		dns\=*)
			SETDNS=`parse_opt "${x}"`
			LOADNET='1'
		;;
		gw\=*)
			SETGW=`parse_opt "${x}"`
			LOADNET='1'
		;;
		gateway\=*)
			SETGW=`parse_opt "${x}"`
			LOADNET='1'
		;;
		dhcphostname\=*)
			DHCPHOSTNAME=`parse_opt "${x}"`
		;;
		netboot\=*)
			NETBOOT=`parse_opt "${x}"`
			LOADNET='1'
		;;
		nfsboot\=*)
			NFSBOOT=`parse_opt "${x}"`
			LOADNET='1'
		;;
		nbdboot\=*)
			NBDBOOT=`parse_opt "${x}"`
			LOADNET='1'
		;;
		boothttp\=*) # old option (deprecated)
			NETBOOT=`parse_opt "${x}"`
			LOADNET='1'
		;;
		boottftp\=*) # old option (deprecated)
			NETBOOT=`parse_opt "${x}"`
			LOADNET='1'
		;;
		isoloop\=*) # iso stored on the disk
			ISOLOOP=`parse_opt "${x}"`
			;;
		subdir\=*)
			SUBDIR=`parse_opt "${x}"`
		;;
		real_init\=*)
			REAL_INIT=`parse_opt "${x}"`
		;;
		speakup\=*)
			SPEAKUP=`parse_opt "${x}"`
		;;
		nocdroot)
			CDROOT=0
		;;
		cdroot\=*)
			CDROOT=1
			CDROOT_DEV=`parse_opt "${x}"`
		;;
		backstore\=*)
			BACKSTORECMD=`parse_opt "${x}"`
		;;
		setkmap\=*)
			SETKMAP=`parse_opt "${x}"`
		;;
		boothd\=*)
			BOOTHD=`parse_opt "${x}"`
		;;
		scandelay\=*)
			SCANDELAY=`parse_opt "${x}"`
		;;
		scandelay)
			SCANDELAY=10
		;;
		doload\=*)
			MODLOAD=`parse_opt "${x}"`
			MODLOAD="`echo ${MODLOAD} | sed -e \"s/,/ /g\"`"
		;;
		nodetect)
			NODETECT=1
		;;
		noload\=*)
			BLACKLIST=`parse_opt "${x}"`
			BLACKLIST="`echo ${BLACKLIST} | sed -e \"s/,/ /g\"`"
		;;
		CONSOLE\=*)
			CONSOLE=`parse_opt "${x}"`
			exec >${CONSOLE} <${CONSOLE} 2>&1
		;;
		docheck)
			DOCHECK=1
		;;
		lowmem)
			LOWMEM=1
		;;
		minishell)
			MINISHELL=1
		;;
	esac
done

# =============================================================================
# =============================================================================

# set terminal in utf8 mode
kbd_mode -u
#/bin/consolechars -f /lat0-sun16.psf
#dumpkeys | loadkeys --unicode

# check that aufs is supported
if ! grep -q aufs /proc/filesystems
then
	bad_msg "Fatal error: aufs filesystem not supported by the kernel."
	while true ; do sleep 1 ; done
fi

sysresccd_udev_start

sysresccd_speakup

sysresccd_netconfig

sysresccd_setup_keymap

# ---- realroot ----
if [ -z "${REAL_ROOT}" ] && [ "${CDROOT}" -eq 0 ] && [ "${FAKE_ROOT}" != "/dev/ram0" ]
then
	REAL_ROOT="${FAKE_ROOT}"
fi

mkdir -p ${NEW_ROOT}

# Check option to boot fromn the hard disk (boothd=/dev/xxx)
if [ -n "$BOOTHD" ]
then
	good_msg "Option to boot from the hard disk: boothd=${BOOTHD}"
	if mount ${BOOTHD} ${NEW_ROOT} 2>/dev/null
	then
		good_msg "Partition ${BOOTHD} was successfully mounted"
		sleep 2
		umount /sys || echo '*: Failed to unmount the initrd /sys!'
		umount /proc || echo '*: Failed to unmount the initrd /proc!'
		sleep 2
		(sleep 3; rm -r /bin/busybox /dev) &
		cd ${NEW_ROOT}
		exec /bin/busybox chroot . /bin/sh <<- EOF
		exec ${INITPROG} ${REAL_INIT}
EOF
	else
		sysresccd_panic "Could not mount partition ${BOOTHD}"
	fi
fi

CHROOT=${NEW_ROOT}

# Run debug shell if requested with "minishell" in cmdline
if [ "${MINISHELL}" = '1' ]
then
	good_msg "Running a mini shell (as requested by the command line)"
	sysresccd_runshell ${MINISHELL}
fi

if [ "${CDROOT}" -eq '1' ]
then
	rm -f /etc/mtab
	ln -s /proc/mounts /etc/mtab

	good_msg "Making tmpfs for ${NEW_ROOT}"
	mount -t tmpfs tmpfs ${NEW_ROOT}

	if [ -n "${NETBOOT}" ]
	then
		sysresccd_bootstrap_net # download ISO via http or tftp
	elif [ -n "${NFSBOOT}" ]
	then
		sysresccd_bootstrap_nfs
	elif [ -n "${NBDBOOT}" ]
	then
		sysresccd_bootstrap_nbd  # boot from an NBD disk
	elif [ -n "${ISOLOOP}" ]
	then
        	sysresccd_findisomount # mount an iso image from and hard-disk
	else
		sysresccd_findcdmount # classic boot via cdrom/harddisk device
	fi

	if [ "${REAL_ROOT}" = '' ]
	then
		echo -n -e "${WARN}>>${NORMAL}${BOLD} No bootable medium found. Waiting for new devices"

		COUNTER=0
		while [ $COUNTER -lt 3 ]; do
			sleep 3
			echo -n '.'
			let COUNTER=$COUNTER+1
		done

		sleep 1
		echo -e "${NORMAL}"
		sysresccd_findcdmount
	fi

	if [ "${REAL_ROOT}" = '' ]
	then
		# Undo stuff
		umount  ${NEW_ROOT}/dev 2>/dev/null
		umount  ${NEW_ROOT}/sys 2>/dev/null
		umount /sys 2>/dev/null

		umount  ${NEW_ROOT}
		rm -rf  ${NEW_ROOT}/*

		sysresccd_panic 'Could not find CD to boot, something else needed!'
	fi
fi

# Setup dmraid for fake raid devices
if [ -x "/sbin/dmraid-activate" ] && ! grep -q 'nodmraid' /proc/cmdline
then
        good_msg "Activating dmraid (fake hardware raid)..."
	if devices=$(dmraid -r -c)
	then
	        for dev in $devices
		do
	                $dev
		done
	fi
fi

# Setup mdadm for linux software raid
if [ -x "/sbin/mdadm" ] && ! grep -q 'nomdadm' /proc/cmdline
then
	good_msg "Loading MD modules for software raid..."
	for mod in linear multipath raid0 raid1 raid456 raid5 raid6 raid10
	do
		modprobe -q ${mod}
	done
	good_msg "Starting mdadm (linux software raid)"
	/sbin/mdadm -Es > /etc/mdadm.conf
	/sbin/mdadm -As
fi

# Setup the Logical Volume Manager
if [ -x "/sbin/lvm" ] && ! grep 'nolvm' /proc/cmdline
then
	good_msg 'Setting up the Logical Volume Manager'
	/sbin/lvm vgscan --ignorelockingfailure --mknodes 2>/dev/null
	/sbin/lvm vgchange -ay --ignorelockingfailure 2>/dev/null
fi

# Determine root device
good_msg 'Determining root device...'

sysresccd_search_rootfs_auto()
{
	REAL_ROOT=''
	sleep 2
	devices="${BLKDEVICES} /dev/mapper/*"
	[ -n "${CDROOT_DEV}" ] && devices="${devices} ${CDROOT_DEV}"
	for curdev in $(sysresccd_expand ${devices})
	do
		# Check for a block device to mount
		if [ -b "${curdev}" ] && [ -z "${REAL_ROOT}" ]
		then
			# check the 'skipmount=/dev/xxx' option (use it with a failing hard drive)
			if echo "$(cat /proc/cmdline) " | grep -F -q "skipmount=${curdev} "
			then
				good_msg "Skipping mount on device :- ${curdev}"
			else
				good_msg "Attempting to mount media:- ${curdev}"

				for curfs in auto
				do
					cmd="mount -r -t $curfs ${curdev} ${NEW_ROOT}"
					${cmd} > /dev/null 2>&1
					res=$?
					if [ "$res" = '0' ]
					then
						good_msg "${curdev} has been successfully mounted"
						if [ -e ${NEW_ROOT}${INITPROG} ]
						then
							good_msg "Program ${INITPROG} found on ${curdev}"
							REAL_ROOT="${curdev}"
							ROOTFS="${curfs}"
						fi
						umount ${NEW_ROOT}
					fi
					sleep 1
				done
			fi
		fi
	done
}

sysresccd_search_rootfs_uuid()
{
	uuid="$1"
	sleep 2
	target="$(/bin/readlink -f /dev/disk/by-uuid/${uuid})"
	if [ -b "${target}" ]
	then
		ROOT_DEV="${target}"
	elif [ -b "/dev/disk/by-uuid/${uuid}" ]
	then
		ROOT_DEV="/dev/disk/by-uuid/${uuid}"
	fi
	if [ -b "${ROOT_DEV}" ]
	then
		good_msg "Found root device: /dev/disk/by-uuid/${uuid} = ${ROOT_DEV}"
		REAL_ROOT="${ROOT_DEV}"
	else
		sysresccd_panic "Could not find root block device having UUID=${uuid}"
	fi
}

sysresccd_search_rootfs_label()
{
	label="$1"
	sleep 2
	target="$(/bin/readlink -f /dev/disk/by-label/${label})"
	if [ -b "${target}" ]
	then
		ROOT_DEV="${target}"
	elif [ -b "/dev/disk/by-label/${label}" ]
	then
		ROOT_DEV="/dev/disk/by-label/${label}"
	fi
	if [ -b "${ROOT_DEV}" ]
	then
		good_msg "Found root device: ${ROOT_DEV}"
		REAL_ROOT="${ROOT_DEV}"
	else
		sysresccd_panic "Could not find root block device having LABEL=${label}"
	fi
}

while true
do
	while [ "${got_good_root}" != '1' ]
	do
		case "${REAL_ROOT}" in
			UUID\=*)
				uuid=`parse_opt "${REAL_ROOT}"`
				sysresccd_search_rootfs_uuid ${uuid}
				;;
			LABEL\=*)
				label=`parse_opt "${REAL_ROOT}"`
				sysresccd_search_rootfs_label ${label}
				;;
			auto)
				sysresccd_search_rootfs_auto
				;;
		esac

		if [ "${REAL_ROOT}" = '' ]
		then	# No REAL_ROOT determined/specified. Prompt user for root block device.
			bad_msg "The root block device is unspecified or not detected."
			echo '   Please specify a device to boot, or "shell" for a shell...'
			echo -n 'boot() :: '
			read REAL_ROOT
			got_good_root=0
		elif [ -b "${REAL_ROOT}" ] || [ "${REAL_ROOT}" = "iso" ] || [ "${REAL_ROOT}" = "http" ] \
			|| [ "${REAL_ROOT}" = "tftp" ] || [ "${REAL_ROOT}" = "nfs" ] || [ "${REAL_ROOT}" = "nbd" ]
		then
			got_good_root=1
		else
			sysresccd_panic "Device ${REAL_ROOT} is not a valid root device..."
		fi
	done

	if [ "${CDROOT}" = '1' ] && [ "${got_good_root}" = '1' ]
	then
		# CD already mounted; no further checks necessary
		break
	else
		if mount -o ro ${REAL_ROOT} ${NEW_ROOT}
		then
			good_msg "Successfully mounted ${REAL_ROOT}"
			break
		else
			bad_msg "Could not mount specified ROOT, try again"
			got_good_root=0
			REAL_ROOT=''
		fi
	fi
done
# End determine root device

# If cdroot is set determine the looptype to boot
if [ "${CDROOT}" = '1' ]
then
	cd ${NEW_ROOT}

	[ -z "${NETBOOT}" ] && [ -z "${NBDBOOT}" ] && sysresccd_cache_cd_contents

	good_msg 'Mounting the squashfs root filesystem'

	if [ "${DOCHECK}" -eq '1' ]
	then
		echo "Checking the ${LOOPDAT} file with md5sum (it may take few minutes)..."
		md5now=$(busybox md5sum /cdrom/${SUBDIR}/${LOOPDAT} | cut -d ' ' -f1)
		md5orig=$(cat /cdrom/${SUBDIR}/${LOOPMD5} | cut -d ' ' -f1)
		if [ "$md5now" = "$md5orig" ]
		then
			good_msg "The ${LOOPDAT} file is valid (md5sum=$md5orig)"
		else
			sysresccd_panic "The root filesystem image has an invalid md5 checksum"
		fi
	fi

	# try 'mount -t squashfs', then 'mount'
	mountpt='/squashfs'
	mkdir -p ${mountpt}

	if [ "${REAL_ROOT}" = "nbd" ]
	then
		squashfsimg="/dev/nbd0"
		squashfsopt=""
	else
		squashfsimg="/cdrom/${SUBDIR}/${LOOPDAT}"
		squashfsopt="-o loop"
	fi

	mountok=''
	for fs in '-t squashfs' ''
	do
		if [ "$mountok" != "ok" ]
		then
			mount ${fs} ${squashfsopt} -o ro ${squashfsimg} ${mountpt} 2>/dev/null && mountok='ok'
		fi
	done

	if [ "$mountok" != "ok" ]
	then
		sysresccd_panic "ERROR: Cannot mount ${LOOPDAT}. Kernel version [$(uname -a)]"
	fi

	good_msg "Preparing the aufs filesystem..."
	mkdir -p /memory /backstore

	# ---- try to find a backing-store loopback ext3
	if [ "${BACKSTORECMD}" != 'off' ]
	then
		BACKSTOREDAT='/sysrcd.bs'
		BACKSTOREOPT=''
		BACKSTOREDEV=''
		for curopt in $(echo ${BACKSTORECMD} | sed -e 's!,! !g')
		do
			case "${curopt}" in
				alldev)
					echo "FOUND OPTION: backstore=alldev (search backstore on alldevices)"
					BACKSTOREOPT='alldev'
					;;
				*)
					echo "FOUND OPTION: backstore=${curopt} (BACKSTOREDAT=${curopt})"
					BACKSTOREDAT=${curopt}
					;;
			esac
		done

		[ -n "${CDROOT_DEV}" ] && BLKDEVICES="$BLKDEVICES ${CDROOT_DEV}"
		BLKDEVICES="$BLKDEVICES /dev/mapper/*" # LVM disks

		if [ "${BACKSTOREOPT}" = 'alldev' ]
		then
			SEARCHDEVICES=$(sysresccd_expand ${BLKDEVICES})
		else
			good_msg "Checking removable devices only for backstore"
			SEARCHDEVICES=$(sysresccd_expand_removable ${REMOVABLE_BLKDEVICES})
		fi

		for curdev in ${SEARCHDEVICES}
		do
			# Check for a block device to mount
			if [ -b "${curdev}" ] && [ -z "${BACKSTOREDEV}" ]
			then
				# check the 'skipmount=/dev/xxx' option (use it with a failing hard drive)
				if cat /proc/cmdline | grep -F -q "skipmount=${curdev} "
				then
					good_msg "Skipping backstore on device :- ${curdev}"
				else
					good_msg "Attempting to find backstore on media:- ${curdev}"

					for curfs in vfat auto
					do
						if mount -r -t ${curfs} ${curdev} /backstore >/dev/null 2>&1
						then
							BACKSTOREPATH="/backstore/${BACKSTOREDAT}"
							if [ -f "${BACKSTOREPATH}" ]
							then
								if mount -o remount,rw,noatime -t ${curfs} ${curdev} /backstore \
									&& touch /backstore/ 2>/dev/null
								then
									if mount -o noatime -w "${BACKSTOREPATH}" /memory
									then
										BACKSTOREDEV="${curdev}"
										good_msg "Backing store ${BACKSTOREDAT} found on ${BACKSTOREDEV}"
									else
										bad_msg "Cannot mount ${BACKSTOREDAT} found on ${curdev}"
									fi
								else
									umount /backstore >/dev/null 2>&1
									bad_msg "Cannot get write-access to ${BACKSTOREDAT} on ${curdev}"
								fi
							else
								umount /backstore >/dev/null 2>&1
							fi
						fi
					done
				fi
			fi
		done
	fi

	# ---- mount the aufs filesystem
	if [ -z "${BACKSTOREDEV}" ] # use RAM to store the changes if no backing-store mounted
	then
		mount -t tmpfs tmpfs /memory
	fi

	if mount -t aufs none ${NEW_ROOT} -o dirs=/memory=rw:${mountpt}=ro -o noatime
	then
		good_msg "The aufs filesystem is ready"

		# copy cached autorun scripts
		autoruns="$(ls -d /cache/autorun* 2>/dev/null)"
		[ "$autoruns" != "" ] && cp $autoruns ${NEW_ROOT}/var/autorun/cdrom
	else
		bad_msg "Fatal error: cannot mount the aufs filesystem."
		while true ; do sleep 1 ; done
	fi

	# ---- move the squashfs mount point
	mkdir -p ${NEW_ROOT}/mnt/livecd 2>/dev/null
	cmd="mount -n --move ${mountpt} ${NEW_ROOT}/mnt/livecd"
	if ! ${cmd}
	then
		echo "${cmd} --> ${res}" && sleep 3
	fi

	# ---- move the backing store mount point
	if [ -n "${BACKSTOREDEV}" ]
	then
		mkdir -p ${NEW_ROOT}/mnt/backstore
		cmd="mount -n --move /backstore ${NEW_ROOT}/mnt/backstore"
		if ! ${cmd}
		then
			echo "${cmd} --> ${res}" && sleep 3
		fi
	fi

	# --- move the /memory mount point
	mkdir -p ${NEW_ROOT}/mnt/memory 2>/dev/null
	cmd="mount -n --move /memory ${NEW_ROOT}/mnt/memory"
	if ! ${cmd}
	then
		echo "${cmd} --> ${res}" && sleep 3
	fi

        # --- move the /cdrom mount point
        mkdir -p ${NEW_ROOT}/mnt/cdrom 2>/dev/null
	if cat /proc/mounts | busybox awk '{print $2}' | grep -q '^/cdrom$'
	then
		cmd="mount -n --move /cdrom ${NEW_ROOT}/mnt/cdrom"
		if ! ${cmd}
		then
		    echo "${cmd} --> ${res}" && sleep 3
		else
		    umount /cdrom 2>/dev/null
		fi
	fi

        # --- move the /isostore mount point
        if [ -n "${ISOLOOPDEV}" ]
        then
            mkdir -p ${NEW_ROOT}/mnt/isostore 2>/dev/null
            cmd="mount -n --move /isostore ${NEW_ROOT}/mnt/isostore"
            if ! ${cmd}
            then
                echo "${cmd} --> ${res}" && sleep 3
            else
                umount /cdrom 2>/dev/null
            fi
        fi

	# make directories
	for curdir in /mnt/custom /mnt/gentoo /mnt/windows /mnt/floppy /mnt/backup \
		/var/run/iptraf /var/log/iptraf /var/spool/cron /var/run/samba \
		/var/log/samba /var/cache/samba /var/log/clamav /var/run/clamav
	do
		mkdir -p "${NEW_ROOT}${curdir}"
	done

	if [ -e /etc/sysconfig/keyboard ]
	then
		mkdir -p ${NEW_ROOT}/etc/sysconfig/
		cp /etc/sysconfig/keyboard ${NEW_ROOT}/etc/sysconfig/keyboard
	fi

	mkdir initrd proc tmp sys 2>/dev/null
	chmod 1777 tmp

	# Let Init scripts know that we booted from CD
	export CDBOOT
	CDBOOT=1

	# if option "lowmem" was enabled then do not start these initscripts
	if [ "${LOWMEM}" = '1' ]
	then
		for initscr in sshd nfs portmap
		do
			rm -f "${NEW_ROOT}/etc/runlevels/default/${initscr}"
		done
	fi
fi

sysresccd_udev_stop

# check the kernel is able to execute /sbin/init
good_msg "Checking ${INITPROG} can be executed by the current kernel..."
inittype="$(readelf -h ${NEW_ROOT}${INITPROG} | grep Class | awk '{print $2}')"
archtype="$(uname -m)"
echo "   ${INITPROG} on the root filesystem is an ${inittype} binary"
echo "   The current running kernel architecture is ${archtype}"
if [ "${inittype}" = 'ELF64' ] && [ "${archtype}" != 'x86_64' ]
then
	sysresccd_panic "You must boot with a 64bit kernel such as rescue64 to run ${INITPROG}"
fi

# move /proc /dev /sys to the new root filesystem
mount -n -o move /dev ${NEW_ROOT}/dev
nuke /dev
ln -s ${NEW_ROOT}/dev /dev

if [ ! -x ${NEW_ROOT}${INITPROG} ]
then
	sysresccd_panic "${INITPROG} not found on root filesystem"
fi

umount /proc
umount /sys

good_msg "Executing ${INITPROG} from the root filesystem..."
exec run-init ${NEW_ROOT} ${INITPROG} <${NEW_ROOT}/dev/console >${NEW_ROOT}/dev/console

# ------------------------------- minishell -------------------------------
sysresccd_panic "Failed to run run-init ${NEW_ROOT} ${INITPROG}"

