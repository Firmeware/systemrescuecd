diff -Nuar efibootmgr-0.5.4.orig/src/efibootmgr/efibootmgr.c efibootmgr-0.5.4/src/efibootmgr/efibootmgr.c
--- efibootmgr-0.5.4.orig/src/efibootmgr/efibootmgr.c	2007-11-12 19:50:28.000000000 +0000
+++ efibootmgr-0.5.4/src/efibootmgr/efibootmgr.c	2012-08-19 23:21:46.257262949 +0000
@@ -43,6 +43,7 @@
 #include <dirent.h>
 #include <unistd.h>
 #include <getopt.h>
+#include <sys/utsname.h>
 #include "list.h"
 #include "efi.h"
 #include "efichar.h"
@@ -68,6 +69,7 @@
 static	LIST_HEAD(boot_entry_list);
 static	LIST_HEAD(blk_list);
 efibootmgr_opt_t opts;
+efi_var_type_t efi_var_type;
 
 static inline void
 var_num_from_name(const char *pattern, char *name, uint16_t *num)
@@ -1029,6 +1031,31 @@
 	int num, num_boot_names=0;
 	efi_status_t ret=0;
 
+	struct utsname u;
+	uname(&u);
+	if (strcmp(u.machine,"i386") == 0) {	
+		efi_var_type = EFI_VAR_TYPE_32;
+	}
+	else if (strcmp(u.machine,"i486") == 0) {	
+		efi_var_type = EFI_VAR_TYPE_32;
+	}
+	else if (strcmp(u.machine,"i586") == 0) {	
+		efi_var_type = EFI_VAR_TYPE_32;
+	}
+	else if (strcmp(u.machine,"i686") == 0) {	
+		efi_var_type = EFI_VAR_TYPE_32;
+	}
+	else if (strcmp(u.machine,"ia64") == 0) {	
+		efi_var_type = EFI_VAR_TYPE_64;
+	}
+	else if (strcmp(u.machine,"x86_64") == 0) {	
+		efi_var_type = EFI_VAR_TYPE_64;
+	}
+	else {
+		efi_var_type = EFI_VAR_TYPE_UNKNOWN;
+		fprintf(stderr, "Unknown kernel machine type %s, variable readings may not corrent\n", u.machine);
+	}
+
 	set_default_opts();
 	parse_opts(argc, argv);
 	if (opts.showversion) {
diff -Nuar efibootmgr-0.5.4.orig/src/include/efi.h efibootmgr-0.5.4/src/include/efi.h
--- efibootmgr-0.5.4.orig/src/include/efi.h	2007-11-12 19:44:20.000000000 +0000
+++ efibootmgr-0.5.4/src/include/efi.h	2012-08-19 22:29:30.346704822 +0000
@@ -105,6 +105,26 @@
 } __attribute__((packed)) efi_variable_t;
 
 
+typedef struct _efi32_variable_t {
+        efi_char16_t  VariableName[1024/sizeof(efi_char16_t)];
+        efi_guid_t    VendorGuid;
+        uint32_t      DataSize;
+        uint8_t          Data[1024];
+	efi_status_t  Status;
+        uint32_t         Attributes;
+} __attribute__((packed)) efi32_variable_t;
+
+
+typedef struct _efi64_variable_t {
+        efi_char16_t  VariableName[1024/sizeof(efi_char16_t)];
+        efi_guid_t    VendorGuid;
+        uint64_t      DataSize;
+        uint8_t          Data[1024];
+	efi_status_t  Status;
+        uint32_t         Attributes;
+} __attribute__((packed)) efi64_variable_t;
+
+
 typedef struct {
 	uint8_t  type;
 	uint8_t  subtype;
diff -Nuar efibootmgr-0.5.4.orig/src/include/efibootmgr.h efibootmgr-0.5.4/src/include/efibootmgr.h
--- efibootmgr-0.5.4.orig/src/include/efibootmgr.h	2007-11-12 19:44:20.000000000 +0000
+++ efibootmgr-0.5.4/src/include/efibootmgr.h	2012-08-19 22:11:38.885527619 +0000
@@ -55,7 +55,13 @@
 	unsigned short int timeout;
 } efibootmgr_opt_t;
 
+typedef enum {
+	EFI_VAR_TYPE_UNKNOWN,
+	EFI_VAR_TYPE_32,
+	EFI_VAR_TYPE_64,
+} efi_var_type_t;
 
 extern efibootmgr_opt_t opts;
+extern efi_var_type_t efi_var_type;
 
 #endif
diff -Nuar efibootmgr-0.5.4.orig/src/lib/efivars_sysfs.c efibootmgr-0.5.4/src/lib/efivars_sysfs.c
--- efibootmgr-0.5.4.orig/src/lib/efivars_sysfs.c	2007-11-12 19:44:20.000000000 +0000
+++ efibootmgr-0.5.4/src/lib/efivars_sysfs.c	2012-08-19 23:31:25.492880809 +0000
@@ -43,18 +43,57 @@
 	char buffer[PATH_MAX+40];
 	if (!name || !var) return EFI_INVALID_PARAMETER;
 	memset(buffer, 0, sizeof(buffer));
+	efi32_variable_t *var32;
+	efi64_variable_t *var64;
+	size_t varsize;
 
 	snprintf(filename, PATH_MAX-1, "%s/%s/raw_var", SYSFS_DIR_EFI_VARS,name);
 	fd = open(filename, O_RDONLY);
 	if (fd == -1) {
 		return EFI_NOT_FOUND;
 	}
-	readsize = read(fd, var, sizeof(*var));
-	if (readsize != sizeof(*var)) {
+
+	/* Fix if kernel efi_variable_t not match */
+	switch (efi_var_type) {
+		case EFI_VAR_TYPE_32:
+			varsize = sizeof(*var32);
+			var32 = malloc(varsize);
+			if (! var32) return EFI_OUT_OF_RESOURCES;
+			readsize = read(fd, var32, varsize);
+		break;
+		case EFI_VAR_TYPE_64:
+			varsize = sizeof(*var64);
+			var64 = malloc(varsize);
+			if (! var64) return EFI_OUT_OF_RESOURCES;
+			readsize = read(fd, var64, varsize);
+		break;
+		default:
+			varsize = sizeof(*var);
+			readsize = read(fd, var, varsize);
+		break;
+	}
+
+	if (readsize != varsize) {
 		close(fd);
 		return EFI_INVALID_PARAMETER;
 	}
 	close(fd);
+        
+	if (efi_var_type == EFI_VAR_TYPE_32) {
+		memcpy(&var->VariableName,&var32->VariableName,sizeof(var32->VariableName));
+		var->DataSize = var32->DataSize;
+		memcpy(&var->Data,&var32->Data,sizeof(var32->Data));
+		var->Status = var32->Status;
+		var->Attributes = var32->Attributes;
+	}
+	else if (efi_var_type == EFI_VAR_TYPE_64) {
+		memcpy(&var->VariableName,&var64->VariableName,sizeof(var64->VariableName));
+		var->DataSize = var64->DataSize;
+		memcpy(&var->Data,&var64->Data,sizeof(var64->Data));
+		var->Status = var64->Status;
+		var->Attributes = var64->Attributes;
+	}
+
 	return var->Status;
 }
 
@@ -64,6 +103,9 @@
 	int fd;
 	size_t writesize;
 	char buffer[PATH_MAX+40];
+	efi32_variable_t *var32;
+	efi64_variable_t *var64;
+	size_t varsize;
 
 	if (!filename || !var) return EFI_INVALID_PARAMETER;
 	memset(buffer, 0, sizeof(buffer));
@@ -72,8 +114,37 @@
 	if (fd == -1) {
 		return EFI_INVALID_PARAMETER;
 	}
-	writesize = write(fd, var, sizeof(*var));
-	if (writesize != sizeof(*var)) {
+	
+	/* Fix if kernel efi_variable_t not match */
+	if (efi_var_type == EFI_VAR_TYPE_32) {
+		varsize = sizeof(*var32);
+		var32 = malloc(varsize);
+		if (! var32) return EFI_OUT_OF_RESOURCES;
+		memcpy(&var32->VariableName,&var->VariableName,sizeof(var32->VariableName));
+		var32->DataSize = var->DataSize;
+		memcpy(&var32->Data,&var->Data,sizeof(var32->Data));
+		var32->Status = var->Status;
+		var32->Attributes = var->Attributes;
+		writesize = write(fd, var32, sizeof(*var32));
+		free(var32);
+	}
+	else if (efi_var_type == EFI_VAR_TYPE_64) {
+		varsize = sizeof(*var64);
+		var64 = malloc(varsize);
+		if (! var64) return EFI_OUT_OF_RESOURCES;
+		memcpy(&var64->VariableName,&var->VariableName,sizeof(var64->VariableName));
+		var64->DataSize = var->DataSize;
+		memcpy(&var64->Data,&var->Data,sizeof(var64->Data));
+		var64->Status = var->Status;
+		var64->Attributes = var->Attributes;
+		writesize = write(fd, var64, sizeof(*var64));
+		free(var64);
+	} else {
+		varsize = sizeof(*var);
+		writesize = write(fd, var, sizeof(*var));
+	}
+	
+	if (writesize != varsize) {
 		close(fd);
 		return EFI_INVALID_PARAMETER;
 	}
