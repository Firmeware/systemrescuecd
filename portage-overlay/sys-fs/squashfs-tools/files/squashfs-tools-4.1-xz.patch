diff -urN squashfs-4.1/squashfs-tools/compressor.c squashfs-4.1-20101223/squashfs-tools/compressor.c
--- squashfs-4.1/squashfs-tools/compressor.c	2010-09-14 17:39:40.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/compressor.c	2010-12-08 02:48:35.000000000 +0000
@@ -25,31 +25,50 @@
 #include "compressor.h"
 #include "squashfs_fs.h"
 
-extern int gzip_compress(void **, char *, char *, int, int, int *);
-extern int gzip_uncompress(char *, char *, int, int, int *);
-extern int lzma_compress(void **, char *, char *, int, int, int *);
-extern int lzma_uncompress(char *, char *, int, int, int *);
-extern int lzo_compress(void **, char *, char *, int, int, int *);
-extern int lzo_uncompress(char *, char *, int, int, int *);
-
-struct compressor compressor[] = {
-#ifdef GZIP_SUPPORT
-	{ gzip_compress, gzip_uncompress, ZLIB_COMPRESSION, "gzip", 1 },
+#ifndef GZIP_SUPPORT
+static struct compressor gzip_comp_ops =  {
+	NULL, NULL, NULL, NULL, NULL, ZLIB_COMPRESSION, "gzip", 0
+};
+#else
+extern struct compressor gzip_comp_ops;
+#endif
+
+#ifndef LZMA_SUPPORT
+static struct compressor lzma_comp_ops = {
+	NULL, NULL, NULL, NULL, NULL, LZMA_COMPRESSION, "lzma", 0
+};
 #else
-	{ NULL, NULL, ZLIB_COMPRESSION, "gzip", 0 },
+extern struct compressor lzma_comp_ops;
 #endif
-#ifdef LZMA_SUPPORT
-	{ lzma_compress, lzma_uncompress, LZMA_COMPRESSION, "lzma", 1 },
+
+#ifndef LZO_SUPPORT
+static struct compressor lzo_comp_ops = {
+	NULL, NULL, NULL, NULL, NULL, LZO_COMPRESSION, "lzo", 0
+};
 #else
-	{ NULL, NULL, LZMA_COMPRESSION, "lzma", 0 },
+extern struct compressor lzo_comp_ops;
 #endif
-#ifdef LZO_SUPPORT
-	{ lzo_compress, lzo_uncompress, LZO_COMPRESSION, "lzo", 1 },
+
+#ifndef XZ_SUPPORT
+static struct compressor xz_comp_ops = {
+	NULL, NULL, NULL, NULL, NULL, XZ_COMPRESSION, "xz", 0
+};
 #else
-	{ NULL, NULL, LZO_COMPRESSION, "lzo", 0 },
+extern struct compressor xz_comp_ops;
 #endif
 
-	{ NULL, NULL , 0, "unknown", 0}
+
+static struct compressor unknown_comp_ops = {
+	NULL, NULL, NULL , NULL, NULL, 0, "unknown", 0
+};
+
+
+struct compressor *compressor[] = {
+	&gzip_comp_ops,
+	&lzma_comp_ops,
+	&lzo_comp_ops,
+	&xz_comp_ops,
+	&unknown_comp_ops
 };
 
 
@@ -57,11 +76,11 @@
 {
 	int i;
 
-	for(i = 0; compressor[i].id; i++)
-		if(strcmp(compressor[i].name, name) == 0)
+	for(i = 0; compressor[i]->id; i++)
+		if(strcmp(compressor[i]->name, name) == 0)
 			break;
 
-	return &compressor[i];
+	return compressor[i];
 }
 
 
@@ -69,11 +88,11 @@
 {
 	int i;
 
-	for(i = 0; compressor[i].id; i++)
-		if(id == compressor[i].id)
+	for(i = 0; compressor[i]->id; i++)
+		if(id == compressor[i]->id)
 			break;
 
-	return &compressor[i];
+	return compressor[i];
 }
 
 
@@ -81,10 +100,29 @@
 {
 	int i;
 
-	for(i = 0; compressor[i].id; i++)
-		if(compressor[i].supported)
+	for(i = 0; compressor[i]->id; i++)
+		if(compressor[i]->supported)
 			fprintf(stderr, "%s\t%s%s\n", indent,
-				compressor[i].name,
-				strcmp(compressor[i].name, def_comp) == 0 ?
+				compressor[i]->name,
+				strcmp(compressor[i]->name, def_comp) == 0 ?
 				" (default)" : "");
 }
+
+
+void display_compressor_usage(char *def_comp)
+{
+	int i;
+
+	for(i = 0; compressor[i]->id; i++)
+		if(compressor[i]->supported) {
+			char *str = strcmp(compressor[i]->name, def_comp) == 0 ?
+				" (default)" : "";
+			if(compressor[i]->usage) {
+				fprintf(stderr, "\t%s%s\n",
+					compressor[i]->name, str);
+				compressor[i]->usage();
+			} else
+				fprintf(stderr, "\t%s (no options)%s\n",
+					compressor[i]->name, str);
+		}
+}
diff -urN squashfs-4.1/squashfs-tools/compressor.h squashfs-4.1-20101223/squashfs-tools/compressor.h
--- squashfs-4.1/squashfs-tools/compressor.h	2010-08-25 19:08:48.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/compressor.h	2010-12-08 02:48:35.000000000 +0000
@@ -21,8 +21,11 @@
  */
 
 struct compressor {
-	int (*compress)(void **, char *, char *, int, int, int *);
-	int (*uncompress)(char *, char *, int, int, int *);
+	int (*init)(void **, int, int);
+	int (*compress)(void *, void *, void *, int, int, int *);
+	int (*uncompress)(void *, void *, int, int, int *);
+	int (*options)(char **, int);
+	void (*usage)();
 	int id;
 	char *name;
 	int supported;
@@ -31,3 +34,25 @@
 extern struct compressor *lookup_compressor(char *);
 extern struct compressor *lookup_compressor_id(int);
 extern void display_compressors(char *, char *);
+extern void display_compressor_usage(char *);
+
+static inline int compressor_options(struct compressor *comp, char *argv[],
+	int argc)
+{
+	if(comp->options == NULL)
+		return -1;
+
+	return comp->options(argv, argc);
+}
+
+
+static inline int compressor_init(struct compressor *comp, void **stream,
+	int block_size, int flags)
+{
+	if(comp->init == NULL)
+		return 0;
+	return comp->init(stream, block_size, flags);
+}
+
+
+
diff -urN squashfs-4.1/squashfs-tools/gzip_wrapper.c squashfs-4.1-20101223/squashfs-tools/gzip_wrapper.c
--- squashfs-4.1/squashfs-tools/gzip_wrapper.c	2010-08-25 19:09:21.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/gzip_wrapper.c	2010-12-08 02:55:52.000000000 +0000
@@ -22,28 +22,48 @@
 #include <stdlib.h>
 #include <zlib.h>
 
-int gzip_compress(void **strm, char *d, char *s, int size, int block_size,
+#include "squashfs_fs.h"
+#include "compressor.h"
+
+static int gzip_init(void **strm, int block_size, int flags)
+{
+	int res;
+	z_stream *stream;
+
+	stream = *strm = malloc(sizeof(z_stream));
+	if(stream == NULL)
+		goto failed;
+
+	stream->zalloc = Z_NULL;
+	stream->zfree = Z_NULL;
+	stream->opaque = 0;
+
+	res = deflateInit(stream, 9);
+	if(res != Z_OK)
+		goto failed2;
+
+	return 0;
+
+failed2:
+	free(stream);
+failed:
+	return -1;
+}
+
+
+static int gzip_compress(void *strm, void *d, void *s, int size, int block_size,
 		int *error)
 {
-	int res = 0;
-	z_stream *stream = *strm;
+	int res;
+	z_stream *stream = strm;
 
-	if(stream == NULL) {
-		if((stream = *strm = malloc(sizeof(z_stream))) == NULL)
-			goto failed;
-
-		stream->zalloc = Z_NULL;
-		stream->zfree = Z_NULL;
-		stream->opaque = 0;
-
-		if((res = deflateInit(stream, 9)) != Z_OK)
-			goto failed;
-	} else if((res = deflateReset(stream)) != Z_OK)
+	res = deflateReset(stream);
+	if(res != Z_OK)
 		goto failed;
 
-	stream->next_in = (unsigned char *) s;
+	stream->next_in = s;
 	stream->avail_in = size;
-	stream->next_out = (unsigned char *) d;
+	stream->next_out = d;
 	stream->avail_out = block_size;
 
 	res = deflate(stream, Z_FINISH);
@@ -67,14 +87,26 @@
 }
 
 
-int gzip_uncompress(char *d, char *s, int size, int block_size, int *error)
+static int gzip_uncompress(void *d, void *s, int size, int block_size, int *error)
 {
 	int res;
 	unsigned long bytes = block_size;
 
-	res = uncompress((unsigned char *) d, &bytes,
-		(const unsigned char *) s, size);
+	res = uncompress(d, &bytes, s, size);
 
 	*error = res;
 	return res == Z_OK ? (int) bytes : -1;
 }
+
+
+struct compressor gzip_comp_ops = {
+	.init = gzip_init,
+	.compress = gzip_compress,
+	.uncompress = gzip_uncompress,
+	.options = NULL,
+	.usage = NULL,
+	.id = ZLIB_COMPRESSION,
+	.name = "gzip",
+	.supported = 1
+};
+
diff -urN squashfs-4.1/squashfs-tools/lzma_wrapper.c squashfs-4.1-20101223/squashfs-tools/lzma_wrapper.c
--- squashfs-4.1/squashfs-tools/lzma_wrapper.c	2010-08-25 19:09:35.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/lzma_wrapper.c	2010-12-08 02:56:51.000000000 +0000
@@ -17,21 +17,27 @@
  * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  *
  * lzma_wrapper.c
+ *
+ * Support for LZMA1 compression using LZMA SDK (4.65 used in
+ * development, other versions may work) http://www.7-zip.org/sdk.html
  */
 
 #include <LzmaLib.h>
 
+#include "squashfs_fs.h"
+#include "compressor.h"
+
 #define LZMA_HEADER_SIZE	(LZMA_PROPS_SIZE + 8)
 
-int lzma_compress(void **strm, char *dest, char *src, int size, int block_size,
+static int lzma_compress(void *strm, void *dest, void *src, int size, int block_size,
 		int *error)
 {
-	unsigned char *d = (unsigned char *) dest, *s = (unsigned char *) src;
+	unsigned char *d = dest;
 	size_t props_size = LZMA_PROPS_SIZE,
 		outlen = block_size - LZMA_HEADER_SIZE;
 	int res;
 
-	res = LzmaCompress(d + LZMA_HEADER_SIZE, &outlen, s, size, d,
+	res = LzmaCompress(dest + LZMA_HEADER_SIZE, &outlen, src, size, dest,
 		&props_size, 5, block_size, 3, 0, 2, 32, 1);
 	
 	if(res == SZ_ERROR_OUTPUT_EOF) {
@@ -73,10 +79,10 @@
 }
 
 
-int lzma_uncompress(char *dest, char *src, int size, int block_size,
+static int lzma_uncompress(void *dest, void *src, int size, int block_size,
 	int *error)
 {
-	unsigned char *d = (unsigned char *) dest, *s = (unsigned char *) src;
+	unsigned char *s = src;
 	size_t outlen, inlen = size - LZMA_HEADER_SIZE;
 	int res;
 
@@ -85,9 +91,22 @@
 		(s[LZMA_PROPS_SIZE + 2] << 16) |
 		(s[LZMA_PROPS_SIZE + 3] << 24);
 
-	res = LzmaUncompress(d, &outlen, s + LZMA_HEADER_SIZE, &inlen,
-		s, LZMA_PROPS_SIZE);
+	res = LzmaUncompress(dest, &outlen, src + LZMA_HEADER_SIZE, &inlen, src,
+		LZMA_PROPS_SIZE);
 	
 	*error = res;
 	return res == SZ_OK ? outlen : -1;
 }
+
+
+struct compressor lzma_comp_ops = {
+	.init = NULL,
+	.compress = lzma_compress,
+	.uncompress = lzma_uncompress,
+	.options = NULL,
+	.usage = NULL,
+	.id = LZMA_COMPRESSION,
+	.name = "lzma",
+	.supported = 1
+};
+
diff -urN squashfs-4.1/squashfs-tools/lzma_xz_wrapper.c squashfs-4.1-20101223/squashfs-tools/lzma_xz_wrapper.c
--- squashfs-4.1/squashfs-tools/lzma_xz_wrapper.c	1970-01-01 01:00:00.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/lzma_xz_wrapper.c	2010-12-16 04:41:26.000000000 +0000
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) 2010
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * lzma_xz_wrapper.c
+ *
+ * Support for LZMA1 compression using XZ Utils liblzma http://tukaani.org/xz/
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <lzma.h>
+
+#include "squashfs_fs.h"
+#include "compressor.h"
+
+#define LZMA_PROPS_SIZE 5
+#define LZMA_UNCOMP_SIZE 8
+#define LZMA_HEADER_SIZE (LZMA_PROPS_SIZE + LZMA_UNCOMP_SIZE)
+
+#define LZMA_OPTIONS 5
+#define MEMLIMIT (32 * 1024 * 1024)
+
+static int lzma_compress(void *dummy, void *dest, void *src,  int size,
+	int block_size, int *error)
+{
+	unsigned char *d = (unsigned char *) dest;
+	lzma_options_lzma opt;
+	lzma_stream strm = LZMA_STREAM_INIT;
+	int res;
+
+	lzma_lzma_preset(&opt, LZMA_OPTIONS);
+	opt.dict_size = block_size;
+
+	res = lzma_alone_encoder(&strm, &opt);
+	if(res != LZMA_OK) {
+		lzma_end(&strm);
+		goto failed;
+	}
+
+	strm.next_out = dest;
+	strm.avail_out = block_size;
+	strm.next_in = src;
+	strm.avail_in = size;
+
+	res = lzma_code(&strm, LZMA_FINISH);
+	lzma_end(&strm);
+
+	if(res == LZMA_STREAM_END) {
+		/*
+	 	 * Fill in the 8 byte little endian uncompressed size field in
+		 * the LZMA header.  8 bytes is excessively large for squashfs
+		 * but this is the standard LZMA header and which is expected by
+		 * the kernel code
+	 	 */
+
+		d[LZMA_PROPS_SIZE] = size & 255;
+		d[LZMA_PROPS_SIZE + 1] = (size >> 8) & 255;
+		d[LZMA_PROPS_SIZE + 2] = (size >> 16) & 255;
+		d[LZMA_PROPS_SIZE + 3] = (size >> 24) & 255;
+		d[LZMA_PROPS_SIZE + 4] = 0;
+		d[LZMA_PROPS_SIZE + 5] = 0;
+		d[LZMA_PROPS_SIZE + 6] = 0;
+		d[LZMA_PROPS_SIZE + 7] = 0;
+
+		return (int) strm.total_out;
+	}
+
+	if(res == LZMA_OK)
+		/*
+	 	 * Output buffer overflow.  Return out of buffer space
+	 	 */
+		return 0;
+
+failed:
+	/*
+	 * All other errors return failure, with the compressor
+	 * specific error code in *error
+	 */
+	*error = res;
+	return -1;
+}
+
+
+static int lzma_uncompress(void *dest, void *src, int size, int block_size,
+	int *error)
+{
+	lzma_stream strm = LZMA_STREAM_INIT;
+	int uncompressed_size = 0, res;
+	unsigned char lzma_header[LZMA_HEADER_SIZE];
+
+	res = lzma_alone_decoder(&strm, MEMLIMIT);
+	if(res != LZMA_OK) {
+		lzma_end(&strm);
+		goto failed;
+	}
+
+	memcpy(lzma_header, src, LZMA_HEADER_SIZE);
+	uncompressed_size = lzma_header[LZMA_PROPS_SIZE] |
+		(lzma_header[LZMA_PROPS_SIZE + 1] << 8) |
+		(lzma_header[LZMA_PROPS_SIZE + 2] << 16) |
+		(lzma_header[LZMA_PROPS_SIZE + 3] << 24);
+	memset(lzma_header + LZMA_PROPS_SIZE, 255, LZMA_UNCOMP_SIZE);
+
+	strm.next_out = dest;
+	strm.avail_out = block_size;
+	strm.next_in = lzma_header;
+	strm.avail_in = LZMA_HEADER_SIZE;
+
+	res = lzma_code(&strm, LZMA_RUN);
+
+	if(res != LZMA_OK || strm.avail_in != 0) {
+		lzma_end(&strm);
+		goto failed;
+	}
+
+	strm.next_in = src + LZMA_HEADER_SIZE;
+	strm.avail_in = size - LZMA_HEADER_SIZE;
+
+	res = lzma_code(&strm, LZMA_FINISH);
+	lzma_end(&strm);
+
+	if(res == LZMA_STREAM_END || (res == LZMA_OK &&
+		strm.total_out >= uncompressed_size && strm.avail_in == 0))
+		return uncompressed_size;
+
+failed:
+	*error = res;
+	return -1;
+}
+
+
+struct compressor lzma_comp_ops = {
+	.init = NULL,
+	.compress = lzma_compress,
+	.uncompress = lzma_uncompress,
+	.options = NULL,
+	.usage = NULL,
+	.id = LZMA_COMPRESSION,
+	.name = "lzma",
+	.supported = 1
+};
+
diff -urN squashfs-4.1/squashfs-tools/lzo_wrapper.c squashfs-4.1-20101223/squashfs-tools/lzo_wrapper.c
--- squashfs-4.1/squashfs-tools/lzo_wrapper.c	2010-09-14 03:00:57.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/lzo_wrapper.c	2010-12-08 02:56:16.000000000 +0000
@@ -2,6 +2,9 @@
  * Copyright (c) 2010 LG Electronics
  * Chan Jeong <chan.jeong@lge.com>
  *
+ * All modifications Copyright (c) 2010
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2,
@@ -25,6 +28,9 @@
 #include <lzo/lzoconf.h>
 #include <lzo/lzo1x.h>
 
+#include "squashfs_fs.h"
+#include "compressor.h"
+
 /* worst-case expansion calculation during compression,
    see LZO FAQ for more information */
 #define LZO_OUTPUT_BUFFER_SIZE(size)	(size + (size/16) + 64 + 3)
@@ -34,25 +40,39 @@
 	lzo_bytep out;
 };
 
-int lzo_compress(void **strm, char *d, char *s, int size, int block_size,
+
+static int squashfs_lzo_init(void **strm, int block_size, int flags)
+{
+	struct lzo_stream *stream;
+
+	if((stream = *strm = malloc(sizeof(struct lzo_stream))) == NULL)
+		goto failed;
+	/* work memory for compression */
+	if((stream->wrkmem = malloc(LZO1X_999_MEM_COMPRESS)) == NULL)
+		goto failed2;
+	/* temporal output buffer */
+	if((stream->out = malloc(LZO_OUTPUT_BUFFER_SIZE(block_size))) == NULL)
+		goto failed3;
+
+	return 0;
+
+failed3:
+	free(stream->wrkmem);
+failed2:
+	free(stream);
+failed:
+	return -1;
+}
+
+
+static int lzo_compress(void *strm, void *d, void *s, int size, int block_size,
 		int *error)
 {
-	int res = 0;
+	int res;
 	lzo_uint outlen;
-	struct lzo_stream *stream = *strm;
-
-	if(stream == NULL) {
-		if((stream = *strm = malloc(sizeof(struct lzo_stream))) == NULL)
-			goto failed;
-		/* work memory for compression */
-		if((stream->wrkmem = malloc(LZO1X_999_MEM_COMPRESS)) == NULL)
-			goto failed;
-		/* temporal output buffer */
-		if((stream->out = malloc(LZO_OUTPUT_BUFFER_SIZE(block_size))) == NULL)
-			goto failed;
-	}
+	struct lzo_stream *stream = strm;
 
-	res = lzo1x_999_compress((lzo_bytep)s, size, stream->out, &outlen, stream->wrkmem);
+	res = lzo1x_999_compress(s, size, stream->out, &outlen, stream->wrkmem);
 	if(res != LZO_E_OK)
 		goto failed;
 	if(outlen >= size)
@@ -77,13 +97,26 @@
 }
 
 
-int lzo_uncompress(char *d, char *s, int size, int block_size, int *error)
+static int lzo_uncompress(void *d, void *s, int size, int block_size, int *error)
 {
 	int res;
 	lzo_uint bytes = block_size;
 
-	res = lzo1x_decompress_safe((lzo_bytep)s, size, (lzo_bytep)d, &bytes, NULL);
+	res = lzo1x_decompress_safe(s, size, d, &bytes, NULL);
 
 	*error = res;
 	return res == LZO_E_OK ? bytes : -1;
 }
+
+
+struct compressor lzo_comp_ops = {
+	.init = squashfs_lzo_init,
+	.compress = lzo_compress,
+	.uncompress = lzo_uncompress,
+	.options = NULL,
+	.usage = NULL,
+	.id = LZO_COMPRESSION,
+	.name = "lzo",
+	.supported = 1
+};
+
diff -urN squashfs-4.1/squashfs-tools/Makefile squashfs-4.1-20101223/squashfs-tools/Makefile
--- squashfs-4.1/squashfs-tools/Makefile	2010-09-17 05:59:24.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/Makefile	2010-11-23 03:29:14.000000000 +0000
@@ -20,20 +20,33 @@
 
 ########### Building LZMA support #############
 #
-# Both XZ Utils liblzma  (http://tukaani.org/xz/) and LZMA SDK
+# LZMA1 compression.
+#
+# Both XZ Utils liblzma (http://tukaani.org/xz/) and LZMA SDK
 # (http://www.7-zip.org/sdk.html) are supported
 #
 # To build using XZ Utils liblzma - install the library and uncomment
-# the XZ_SUPPORT line below.
+# the LZMA_XZ_SUPPORT line below.
 #
 # To build using the LZMA SDK (4.65 used in development, other versions may
 # work) - download and unpack it, uncomment and set LZMA_DIR to unpacked source,
 # and uncomment the LZMA_SUPPORT line below.
 #
-XZ_SUPPORT = 1
+#LZMA_XZ_SUPPORT = 1
 #LZMA_SUPPORT = 1
 #LZMA_DIR = ../../../LZMA/lzma465
 
+########### Building XZ support #############
+#
+# LZMA2 compression.
+#
+# XZ Utils liblzma (http://tukaani.org/xz/) is supported
+#
+# To build using XZ Utils liblzma - install the library and uncomment
+# the XZ_SUPPORT line below.
+#
+#XZ_SUPPORT = 1
+
 
 ############ Building LZO support ##############
 #
@@ -43,7 +56,7 @@
 # LZO_SUPPORT line below. If needed, uncomment and set LZO_DIR to the
 # installation prefix.
 #
-LZO_SUPPORT = 1
+#LZO_SUPPORT = 1
 #LZO_DIR = /usr/local
 
 
@@ -109,12 +122,20 @@
 COMPRESSORS += lzma
 endif
 
-ifdef XZ_SUPPORT
+ifdef LZMA_XZ_SUPPORT
 CFLAGS += -DLZMA_SUPPORT
+MKSQUASHFS_OBJS += lzma_xz_wrapper.o
+UNSQUASHFS_OBJS += lzma_xz_wrapper.o
+LIBS += -llzma
+COMPRESSORS += lzma
+endif
+
+ifdef XZ_SUPPORT
+CFLAGS += -DXZ_SUPPORT
 MKSQUASHFS_OBJS += xz_wrapper.o
 UNSQUASHFS_OBJS += xz_wrapper.o
 LIBS += -llzma
-COMPRESSORS += lzma
+COMPRESSORS += xz
 endif
 
 ifdef LZO_SUPPORT
@@ -149,11 +170,11 @@
 endif
 
 #
-# Both XZ_SUPPORT and LZMA_SUPPORT cannot be specified
+# Both LZMA_XZ_SUPPORT and LZMA_SUPPORT cannot be specified
 #
-ifdef XZ_SUPPORT
+ifdef LZMA_XZ_SUPPORT
 ifdef LZMA_SUPPORT
-$(error "Both XZ_SUPPORT and LZMA_SUPPORT cannot be specified")
+$(error "Both LZMA_XZ_SUPPORT and LZMA_SUPPORT cannot be specified")
 endif
 endif
 
@@ -161,7 +182,7 @@
 # At least one compressor must have been selected
 #
 ifndef COMPRESSORS
-$(error "No compressor selected! Select one or more of GZIP, LZMA, or LZO!")
+$(error "No compressor selected! Select one or more of GZIP, LZMA, XZ or LZO!")
 endif
 
 #
diff -urN squashfs-4.1/squashfs-tools/mksquashfs.c squashfs-4.1-20101223/squashfs-tools/mksquashfs.c
--- squashfs-4.1/squashfs-tools/mksquashfs.c	2010-09-19 22:44:11.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/mksquashfs.c	2010-12-20 03:12:02.000000000 +0000
@@ -384,9 +384,10 @@
 #define FRAGMENT_BUFFER_DEFAULT 64
 int writer_buffer_size;
 
-/* compression operations structure */
+/* compression operations */
 static struct compressor *comp;
-char *comp_name = COMP_DEFAULT;
+int compressor_opts_parsed = 0;
+void *stream = NULL;
 
 /* xattr stats */
 unsigned int xattr_bytes = 0, total_xattr_bytes = 0;
@@ -439,7 +440,8 @@
 	if(queue == NULL)
 		goto failed;
 
-	if((queue->data = malloc(sizeof(void *) * (size + 1))) == NULL) {
+	queue->data = malloc(sizeof(void *) * (size + 1));
+	if(queue->data == NULL) {
 		free(queue);
 		goto failed;
 	}
@@ -859,7 +861,7 @@
 }
 
 
-int mangle2(void **strm, char *d, char *s, int size,
+int mangle2(void *strm, char *d, char *s, int size,
 	int block_size, int uncompressed, int data_block)
 {
 	int error, c_byte = 0;
@@ -884,9 +886,7 @@
 int mangle(char *d, char *s, int size, int block_size,
 	int uncompressed, int data_block)
 {
-	static void *stream = NULL;
-
-	return mangle2(&stream, d, s, size, block_size, uncompressed,
+	return mangle2(stream, d, s, size, block_size, uncompressed,
 		data_block);
 }
 
@@ -1406,7 +1406,8 @@
 		char buff[65536];
 		size_t off = offsetof(squashfs_symlink_inode_header, symlink);
 
-		if((byte = readlink(filename, buff, 65536)) == -1) {
+		byte = readlink(filename, buff, 65536);
+		if(byte == -1) {
 			ERROR("Failed to read symlink %s, creating empty "
 				"symlink\n", filename);
 			byte = 0;
@@ -1432,7 +1433,8 @@
 		char buff[65536];
 		size_t off = offsetof(squashfs_symlink_inode_header, symlink);
 
-		if((byte = readlink(filename, buff, 65536)) == -1) {
+		byte = readlink(filename, buff, 65536);
+		if(byte == -1) {
 			ERROR("Failed to read symlink %s, creating empty "
 				"symlink\n", filename);
 			byte = 0;
@@ -1487,7 +1489,8 @@
 
 void scan3_init_dir(struct directory *dir)
 {
-	if((dir->buff = malloc(SQUASHFS_METADATA_SIZE)) == NULL) {
+	dir->buff = malloc(SQUASHFS_METADATA_SIZE);
+	if(dir->buff == NULL) {
 		BAD_ERROR("Out of memory allocating directory buffer\n");
 	}
 
@@ -1507,10 +1510,10 @@
 	squashfs_dir_entry idir;
 	unsigned int start_block = inode >> 16;
 	unsigned int offset = inode & 0xffff;
-	unsigned int size;
+	unsigned int size = strlen(name);
 	size_t name_off = offsetof(squashfs_dir_entry, name);
 
-	if((size = strlen(name)) > SQUASHFS_NAME_LEN) {
+	if(size > SQUASHFS_NAME_LEN) {
 		size = SQUASHFS_NAME_LEN;
 		ERROR("Filename is greater than %d characters, truncating! ..."
 			"\n", SQUASHFS_NAME_LEN);
@@ -1594,7 +1597,7 @@
 	struct directory *dir)
 {
 	unsigned int dir_size = dir->p - dir->buff;
-	int data_space = (directory_cache_size - directory_cache_bytes);
+	int data_space = directory_cache_size - directory_cache_bytes;
 	unsigned int directory_block, directory_offset, i_count, index;
 	unsigned short c_byte;
 
@@ -1697,7 +1700,8 @@
 				buffer[idir.size + 1] = '\0';
 				TRACE("\t\tname %s, inode offset 0x%x, type "
 					"%d\n", buffer, idir.offset, idir.type);
-				dirp += sizeof(squashfs_dir_entry) + idir.size +					 1;
+				dirp += sizeof(squashfs_dir_entry) + idir.size +
+					1;
 			}
 		}
 	}
@@ -1868,7 +1872,8 @@
 	if(fragment_size + file_buffer->size > block_size)
 		write_fragment();
 
-	if((ffrg = malloc(sizeof(struct fragment))) == NULL)
+	ffrg = malloc(sizeof(struct fragment));
+	if(ffrg == NULL)
 		BAD_ERROR("Out of memory in fragment block allocation!\n");
 
 	if(fragment_size == 0)
@@ -2067,7 +2072,8 @@
 		return;
 	}
 
-	if((frg = malloc(sizeof(struct fragment))) == NULL)
+	frg = malloc(sizeof(struct fragment));
+	if(frg == NULL)
 		BAD_ERROR("Out of memory in fragment block allocation!\n");
 
 	frg->index = fragment;
@@ -2122,9 +2128,9 @@
 	unsigned short checksum, unsigned short fragment_checksum,
 	int checksum_flag)
 {
-	struct file_info *dupl_ptr;
+	struct file_info *dupl_ptr = malloc(sizeof(struct file_info));
 
-	if((dupl_ptr = malloc(sizeof(struct file_info))) == NULL) {
+	if(dupl_ptr == NULL) {
 		BAD_ERROR("Out of memory in dup_files allocation!\n");
 	}
 
@@ -2355,7 +2361,8 @@
 	frag_block = !no_fragments && (always_use_fragments ||
 		(read_size < block_size)) ? read_size >> block_log : -1;
 
-	if((file = open(dir_ent->pathname, O_RDONLY)) == -1) {
+	file = open(dir_ent->pathname, O_RDONLY);
+	if(file == -1) {
 		file_buffer = cache_get(reader_buffer, 0, 0);
 		file_buffer->sequence = seq ++;
 		goto read_err;
@@ -2556,11 +2563,15 @@
 void *deflator(void *arg)
 {
 	void *stream = NULL;
-	int oldstate;
+	int res, oldstate;
 
 	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldstate);
 	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldstate);
 
+	res = compressor_init(comp, &stream, block_size, 1);
+	if(res)
+		BAD_ERROR("deflator:: compressor_init failed\n");
+
 	while(1) {
 		struct file_buffer *file_buffer = queue_get(from_reader);
 		struct file_buffer *write_buffer;
@@ -2573,7 +2584,7 @@
 			queue_put(from_deflate, file_buffer);
 		} else {
 			write_buffer = cache_get(writer_buffer, 0, 0);
-			write_buffer->c_byte = mangle2(&stream,
+			write_buffer->c_byte = mangle2(stream,
 				write_buffer->data, file_buffer->data,
 				file_buffer->size, block_size, noD, 1);
 			write_buffer->sequence = file_buffer->sequence;
@@ -2593,11 +2604,15 @@
 void *frag_deflator(void *arg)
 {
 	void *stream = NULL;
-	int oldstate;
+	int res, oldstate;
 
 	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldstate);
 	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldstate);
 
+	res = compressor_init(comp, &stream, block_size, 1);
+	if(res)
+		BAD_ERROR("frag_deflator:: compressor_init failed\n");
+
 	while(1) {
 		int c_byte, compressed_size;
 		struct file_buffer *file_buffer = queue_get(to_frag);
@@ -2605,7 +2620,7 @@
 			cache_get(writer_buffer, file_buffer->block +
 			FRAG_INDEX, 1);
 
-		c_byte = mangle2(&stream, write_buffer->data, file_buffer->data,
+		c_byte = mangle2(stream, write_buffer->data, file_buffer->data,
 			file_buffer->size, block_size, noF, 1);
 		compressed_size = SQUASHFS_COMPRESSED_SIZE_BLOCK(c_byte);
 		write_buffer->size = compressed_size;
@@ -2959,7 +2974,8 @@
 
 	*duplicate_file = FALSE;
 
-	if((block_list = malloc(blocks * sizeof(unsigned int))) == NULL)
+	block_list = malloc(blocks * sizeof(unsigned int));
+	if(block_list == NULL)
 		BAD_ERROR("Out of memory allocating block_list\n");
 
 	lock_fragments();
@@ -3297,7 +3313,8 @@
 		inode = inode->next;
 	}
 
-	if((inode = malloc(sizeof(struct inode_info))) == NULL)
+	inode = malloc(sizeof(struct inode_info));
+	if(inode == NULL)
 		BAD_ERROR("Out of memory in inode hash table entry allocation"
 			"\n");
 
@@ -3334,7 +3351,8 @@
 			BAD_ERROR("Out of memory in add_dir_entry\n");
 	}
 
-	if((dir->list[dir->count] = malloc(sizeof(struct dir_ent))) == NULL)
+	dir->list[dir->count] = malloc(sizeof(struct dir_ent));
+	if(dir->list[dir->count] == NULL)
 		BAD_ERROR("Out of memory in linux_opendir\n");
 
 	if(sub_dir)
@@ -3371,7 +3389,8 @@
 {
 	struct dir_info *dir;
 
-	if((dir = malloc(sizeof(struct dir_info))) == NULL)
+	dir = malloc(sizeof(struct dir_info));
+	if(dir == NULL)
 		BAD_ERROR("Out of memory in scan1_opendir\n");
 
 	if(pathname[0] != '\0' && (dir->linuxdir = opendir(pathname)) == NULL) {
@@ -3390,27 +3409,30 @@
 
 int scan1_encomp_readdir(char *pathname, char *dir_name, struct dir_info *dir)
 {
-	int i, n, pass;
-	char *basename;
 	static int index = 0;
 
-	if(dir->count < old_root_entries)
+	if(dir->count < old_root_entries) {
+		int i;
+
 		for(i = 0; i < old_root_entries; i++) {
 			if(old_root_entry[i].inode.type == SQUASHFS_DIR_TYPE)
 				dir->directory_count ++;
 			add_dir_entry(old_root_entry[i].name, "", NULL,
 				&old_root_entry[i].inode, dir);
 		}
+	}
 
 	while(index < source) {
-		if((basename = getbase(source_path[index])) == NULL) {
+		char *basename = getbase(source_path[index]);
+		int n, pass = 1;
+
+		if(basename == NULL) {
 			ERROR("Bad source directory %s - skipping ...\n",
 				source_path[index]);
 			index ++;
 			continue;
 		}
 		strcpy(dir_name, basename);
-		pass = 1;
 		for(;;) {
 			for(n = 0; n < dir->count &&
 				strcmp(dir->list[n]->name, dir_name) != 0; n++);
@@ -3431,19 +3453,21 @@
 int scan1_single_readdir(char *pathname, char *dir_name, struct dir_info *dir)
 {
 	struct dirent *d_name;
-	int i, pass;
+	int i;
 
-	if(dir->count < old_root_entries)
+	if(dir->count < old_root_entries) {
 		for(i = 0; i < old_root_entries; i++) {
 			if(old_root_entry[i].inode.type == SQUASHFS_DIR_TYPE)
 				dir->directory_count ++;
 			add_dir_entry(old_root_entry[i].name, "", NULL,
 				&old_root_entry[i].inode, dir);
 		}
+	}
 
 	if((d_name = readdir(dir->linuxdir)) != NULL) {
+		int pass = 1;
+
 		strcpy(dir_name, d_name->d_name);
-		pass = 1;
 		for(;;) {
 			for(i = 0; i < dir->count &&
 				strcmp(dir->list[i]->name, dir_name) != 0; i++);
@@ -3465,9 +3489,9 @@
 
 int scan1_readdir(char *pathname, char *dir_name, struct dir_info *dir)
 {
-	struct dirent *d_name;
+	struct dirent *d_name = readdir(dir->linuxdir);
 
-	if((d_name = readdir(dir->linuxdir)) != NULL) {
+	if(d_name != NULL) {
 		strcpy(dir_name, d_name->d_name);
 		strcat(strcat(strcpy(pathname, dir->pathname), "/"),
 			d_name->d_name);
@@ -3558,7 +3582,8 @@
 
 	dir_scan2(dir_info, pseudo);
 
-	if((dir_ent = malloc(sizeof(struct dir_ent))) == NULL)
+	dir_ent = malloc(sizeof(struct dir_ent));
+	if(dir_ent == NULL)
 		BAD_ERROR("Out of memory in dir_scan\n");
 
 	if(pathname[0] == '\0') {
@@ -3614,17 +3639,18 @@
 struct dir_info *dir_scan1(char *pathname, struct pathnames *paths,
 	int (_readdir)(char *, char *, struct dir_info *))
 {
-	struct dir_info *dir, *sub_dir;
-	struct stat buf;
 	char filename[8192], dir_name[8192];
-	struct pathnames *new;
+	struct dir_info *dir = scan1_opendir(pathname);
 
-	if((dir = scan1_opendir(pathname)) == NULL) {
+	if(dir == NULL) {
 		ERROR("Could not open %s, skipping...\n", pathname);
 		goto error;
 	}
 
 	while(_readdir(filename, dir_name, dir) != FALSE) {
+		struct dir_info *sub_dir;
+		struct stat buf;
+		struct pathnames *new;
 
 		if(strcmp(dir_name, ".") == 0 || strcmp(dir_name, "..") == 0)
 			continue;
@@ -4059,7 +4085,8 @@
 #endif
 	}
 
-	if((thread = malloc((2 + processors * 2) * sizeof(pthread_t))) == NULL)
+	thread = malloc((2 + processors * 2) * sizeof(pthread_t));
+	if(thread == NULL)
 		BAD_ERROR("Out of memory allocating thread descriptors\n");
 	deflator_thread = &thread[2];
 	frag_deflator_thread = &deflator_thread[processors];
@@ -4170,7 +4197,8 @@
 	target = get_component(target, targname);
 
 	if(paths == NULL) {
-		if((paths = malloc(sizeof(struct pathname))) == NULL)
+		paths = malloc(sizeof(struct pathname));
+		if(paths == NULL)
 			BAD_ERROR("failed to allocate paths\n");
 
 		paths->names = 0;
@@ -4388,7 +4416,8 @@
 		return;
 	}
 
-	if((metadata = malloc(bytes)) == NULL)
+	metadata = malloc(bytes);
+	if(metadata == NULL)
 		BAD_ERROR("Failed to alloc metadata buffer in "
 			"write_recovery_data\n");
 
@@ -4436,7 +4465,8 @@
 	char header[] = RECOVER_ID;
 	char header2[RECOVER_ID_SIZE];
 
-	if((recoverfd = open(recovery_file, O_RDONLY)) == -1)
+	recoverfd = open(recovery_file, O_RDONLY);
+	if(recoverfd == -1)
 		BAD_ERROR("Failed to open recovery file because %s\n",
 			strerror(errno));
 
@@ -4444,7 +4474,8 @@
 		BAD_ERROR("Failed to stat destination file, because %s\n",
 			strerror(errno));
 
-	if((fd = open(destination_file, O_RDWR)) == -1)
+	fd = open(destination_file, O_RDWR);
+	if(fd == -1)
 		BAD_ERROR("Failed to open destination file because %s\n",
 			strerror(errno));
 
@@ -4475,7 +4506,8 @@
 
 	bytes = sBlk.bytes_used - sBlk.inode_table_start;
 
-	if((metadata = malloc(bytes)) == NULL)
+	metadata = malloc(bytes);
+	if(metadata == NULL)
 		BAD_ERROR("Failed to alloc metadata buffer in "
 			"read_recovery_data\n");
 
@@ -4501,7 +4533,7 @@
 
 
 #define VERSION() \
-	printf("mksquashfs version 4.1 (2010/09/19)\n");\
+	printf("mksquashfs version 4.1-CVS (2010/12/19)\n");\
 	printf("copyright (C) 2010 Phillip Lougher "\
 		"<phillip@lougher.demon.co.uk>\n\n"); \
 	printf("This program is free software; you can redistribute it and/or"\
@@ -4521,7 +4553,7 @@
 int main(int argc, char *argv[])
 {
 	struct stat buf, source_buf;
-	int i;
+	int res, i;
 	squashfs_super_block sBlk;
 	char *b, *root_name = NULL;
 	int nopad = FALSE, keep_as_directory = FALSE;
@@ -4542,14 +4574,50 @@
 		goto printOptions;
 	source_path = argv + 1;
 	source = i - 2;
+	/*
+	 * lookup default compressor.  Note the Makefile ensures the default
+	 * compressor has been built, and so we don't need to to check
+	 * for failure here
+	 */
+	comp = lookup_compressor(COMP_DEFAULT);
 	for(; i < argc; i++) {
 		if(strcmp(argv[i], "-comp") == 0) {
+			if(compressor_opts_parsed) {
+				ERROR("%s: -comp must appear before -X options"
+					"\n", argv[0]);
+				exit(1);
+			}
 			if(++i == argc) {
 				ERROR("%s: -comp missing compression type\n",
 					argv[0]);
 				exit(1);
 			}
-			comp_name = argv[i];
+			comp = lookup_compressor(argv[i]);
+			if(!comp->supported) {
+				ERROR("%s: Compressor \"%s\" is not supported!"
+					"\n", argv[0], argv[i]);
+				ERROR("%s: Compressors available:\n", argv[0]);
+				display_compressors("", COMP_DEFAULT);
+				exit(1);
+			}
+
+		} else if(strncmp(argv[i], "-X", 2) == 0) {
+			int args = compressor_options(comp, argv + i, argc - i);
+			if(args < 0) {
+				if(args == -1) {
+					ERROR("%s: Unrecognised compressor"
+						" option %s\n", argv[0],
+						argv[i]);
+					ERROR("%s: Did you forget to specify"
+						" -comp, or specify it after"
+						" the compressor specific"
+						" option?\n", argv[0]);
+					}
+				exit(1);
+			}
+			i += args;
+			compressor_opts_parsed = 1;
+
 		} else if(strcmp(argv[i], "-pf") == 0) {
 			if(++i == argc) {
 				ERROR("%s: -pf missing filename\n", argv[0]);
@@ -4857,7 +4925,7 @@
 			ERROR("-write-queue <size>\tSet output queue to <size> "
 				"Mbytes.  Default %d Mbytes\n",
 				WRITER_BUFFER_DEFAULT);
-			ERROR("-fragment-queue <size>\tSet fagment queue to "
+			ERROR("-fragment-queue <size>\tSet fragment queue to "
 				"<size> Mbytes.  Default %d Mbytes\n",
 				FRAGMENT_BUFFER_DEFAULT);
 			ERROR("\nMiscellaneous options:\n");
@@ -4871,8 +4939,9 @@
 				"-noF\n");
 			ERROR("-noXattrCompression\talternative name for "
 				"-noX\n");
-			ERROR("\nCompressors available:\n");
-			display_compressors("", COMP_DEFAULT);
+			ERROR("\nCompressors available and compressor specific "
+				"options:\n");
+			display_compressor_usage(COMP_DEFAULT);
 			exit(1);
 		}
 	}
@@ -5001,23 +5070,20 @@
 		noI = SQUASHFS_UNCOMPRESSED_INODES(sBlk.flags);
 		noD = SQUASHFS_UNCOMPRESSED_DATA(sBlk.flags);
 		noF = SQUASHFS_UNCOMPRESSED_FRAGMENTS(sBlk.flags);
+		noX = SQUASHFS_UNCOMPRESSED_XATTRS(sBlk.flags);
 		no_fragments = SQUASHFS_NO_FRAGMENTS(sBlk.flags);
 		always_use_fragments = SQUASHFS_ALWAYS_FRAGMENTS(sBlk.flags);
 		duplicate_checking = SQUASHFS_DUPLICATES(sBlk.flags);
 		exportable = SQUASHFS_EXPORTABLE(sBlk.flags);
-	} else {
-		comp = lookup_compressor(comp_name);
-		if(!comp->supported) {
-			ERROR("FATAL_ERROR: Compressor \"%s\" is not "
-				"supported!\n", comp_name);
-			ERROR("Compressors available:\n");
-			display_compressors("", COMP_DEFAULT);
-			EXIT_MKSQUASHFS();
-		}
+		no_xattrs = SQUASHFS_NO_XATTRS(sBlk.flags);
 	}
 
 	initialise_threads(readb_mbytes, writeb_mbytes, fragmentb_mbytes);
 
+	res = compressor_init(comp, &stream, SQUASHFS_METADATA_SIZE, 0);
+	if(res)
+		BAD_ERROR("compressor_init failed\n");
+
 	if(delete) {
 		printf("Creating %d.%d filesystem on %s, block size %d.\n",
 			SQUASHFS_MAJOR, s_minor, argv[source + 1], block_size);
@@ -5061,7 +5127,7 @@
 		printf("Appending to existing %d.%d filesystem on %s, block "
 			"size %d\n", SQUASHFS_MAJOR, s_minor, argv[source + 1],
 			block_size);
-		printf("All -b, -noI, -noD, -noF, no-duplicates, no-fragments, "
+		printf("All -b, -noI, -noD, -noF, -noX, no-duplicates, no-fragments, "
 			"-always-use-fragments,\n-exportable and -comp options "
 			"ignored\n");
 		printf("\nIf appending is not wanted, please re-run with "
@@ -5195,8 +5261,9 @@
 	sBlk.s_minor = s_minor;
 	sBlk.block_size = block_size;
 	sBlk.block_log = block_log;
-	sBlk.flags = SQUASHFS_MKFLAGS(noI, noD, noF, no_fragments,
-		always_use_fragments, duplicate_checking, exportable);
+	sBlk.flags = SQUASHFS_MKFLAGS(noI, noD, noF, noX, no_fragments,
+		always_use_fragments, duplicate_checking, exportable,
+		no_xattrs);
 	sBlk.mkfs_time = time(NULL);
 
 restore_filesystem:
diff -urN squashfs-4.1/squashfs-tools/read_fs.c squashfs-4.1-20101223/squashfs-tools/read_fs.c
--- squashfs-4.1/squashfs-tools/read_fs.c	2010-09-16 03:51:53.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/read_fs.c	2010-12-15 09:46:55.000000000 +0000
@@ -363,7 +363,8 @@
 		}
 	}
 	
-	return files;
+	printf("Read existing filesystem, %d inodes scanned\n", files);
+	return TRUE;
 
 
 failed:
@@ -414,6 +415,7 @@
 	if(!comp->supported) {
 		ERROR("Filesystem on %s uses %s compression, this is"
 			"unsupported by this version\n", source, comp->name);
+		ERROR("Compressors available:\n");
 		display_compressors("", "");
 		goto failed_mount;
 	}
@@ -427,12 +429,16 @@
 		SQUASHFS_UNCOMPRESSED_DATA(sBlk->flags) ? "un" : "");
 	printf("\tFragments are %scompressed\n",
 		SQUASHFS_UNCOMPRESSED_FRAGMENTS(sBlk->flags) ? "un" : "");
+	printf("\tXattrs are %scompressed\n",
+		SQUASHFS_UNCOMPRESSED_XATTRS(sBlk->flags) ? "un" : "");
 	printf("\tFragments are %spresent in the filesystem\n",
 		SQUASHFS_NO_FRAGMENTS(sBlk->flags) ? "not " : "");
 	printf("\tAlways_use_fragments option is %sspecified\n",
 		SQUASHFS_ALWAYS_FRAGMENTS(sBlk->flags) ? "" : "not ");
 	printf("\tDuplicates are %sremoved\n",
 		SQUASHFS_DUPLICATES(sBlk->flags) ? "" : "not ");
+	printf("\tXattrs are %sstored\n",
+		SQUASHFS_NO_XATTRS(sBlk->flags) ? "not " : "");
 	printf("\tFilesystem size %.2f Kbytes (%.2f Mbytes)\n",
 		sBlk->bytes_used / 1024.0, sBlk->bytes_used
 		/ (1024.0 * 1024.0));
@@ -691,7 +697,7 @@
 		SQUASHFS_INODE_BLK(sBlk->root_inode);
 	unsigned int root_inode_offset =
 		SQUASHFS_INODE_OFFSET(sBlk->root_inode);
-	unsigned int root_inode_block, files;
+	unsigned int root_inode_block;
 	squashfs_inode_header inode;
 	unsigned int *id_table;
 	int res;
@@ -711,20 +717,18 @@
 	if(id_table == NULL)
 		goto error;
 
-	if((files = scan_inode_table(fd, start, end, root_inode_start,
-			root_inode_offset, sBlk, &inode, &inode_table,
-			&root_inode_block, root_inode_size, uncompressed_file,
-			uncompressed_directory, file_count, sym_count,
-			dev_count, dir_count, fifo_count, sock_count, id_table))
-			== 0) {
+	res = scan_inode_table(fd, start, end, root_inode_start,
+		root_inode_offset, sBlk, &inode, &inode_table,
+		&root_inode_block, root_inode_size, uncompressed_file,
+		uncompressed_directory, file_count, sym_count, dev_count,
+		dir_count, fifo_count, sock_count, id_table);
+	if(res == 0) {
 		ERROR("read_filesystem: inode table read failed\n");
 		goto error;
 	}
 
 	*uncompressed_inode = root_inode_block;
 
-	printf("Read existing filesystem, %d inodes scanned\n", files);
-
 	if(inode.base.inode_type == SQUASHFS_DIR_TYPE ||
 			inode.base.inode_type == SQUASHFS_LDIR_TYPE) {
 		if(inode.base.inode_type == SQUASHFS_DIR_TYPE) {
diff -urN squashfs-4.1/squashfs-tools/squashfs_fs.h squashfs-4.1-20101223/squashfs-tools/squashfs_fs.h
--- squashfs-4.1/squashfs-tools/squashfs_fs.h	2010-09-16 04:04:43.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/squashfs_fs.h	2010-12-15 09:13:56.000000000 +0000
@@ -61,6 +61,8 @@
 #define SQUASHFS_ALWAYS_FRAG		5
 #define SQUASHFS_DUPLICATE		6
 #define SQUASHFS_EXPORT			7
+#define SQUASHFS_NOX			8
+#define SQUASHFS_NO_XATTR		9
 
 #define SQUASHFS_BIT(flag, bit)		((flag >> bit) & 1)
 
@@ -85,10 +87,17 @@
 #define SQUASHFS_EXPORTABLE(flags)		SQUASHFS_BIT(flags, \
 						SQUASHFS_EXPORT)
 
-#define SQUASHFS_MKFLAGS(noi, nod, nof, no_frag, always_frag, \
-		duplicate_checking, exportable)	(noi | (nod << 1) | \
+#define SQUASHFS_UNCOMPRESSED_XATTRS(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOX)
+
+#define SQUASHFS_NO_XATTRS(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_NO_XATTR)
+
+#define SQUASHFS_MKFLAGS(noi, nod, nof, nox, no_frag, always_frag, \
+		duplicate_checking, exportable, no_xattr) (noi | (nod << 1) | \
 		(nof << 3) | (no_frag << 4) | (always_frag << 5) | \
-		(duplicate_checking << 6) | (exportable << 7))
+		(duplicate_checking << 6) | (exportable << 7) | (nox << 8) | \
+		(no_xattr << 9))
 
 /* Max number of types and file types */
 #define SQUASHFS_DIR_TYPE		1
@@ -259,6 +268,7 @@
 #define ZLIB_COMPRESSION	1
 #define LZMA_COMPRESSION	2
 #define LZO_COMPRESSION		3
+#define XZ_COMPRESSION		4
 
 struct squashfs_super_block {
 	unsigned int		s_magic;
diff -urN squashfs-4.1/squashfs-tools/unsquash-1.c squashfs-4.1-20101223/squashfs-tools/unsquash-1.c
--- squashfs-4.1/squashfs-tools/unsquash-1.c	2010-08-25 19:25:33.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/unsquash-1.c	2010-12-16 04:17:11.000000000 +0000
@@ -138,7 +138,7 @@
 
 			i.data = inode->file_size;
 			i.time = inode->mtime;
-			i.blocks = (inode->file_size + sBlk.s.block_size - 1) >>
+			i.blocks = (i.data + sBlk.s.block_size - 1) >>
 				sBlk.s.block_log;
 			i.start = inode->start_block;
 			i.block_ptr = block_ptr + sizeof(*inode);
@@ -226,7 +226,8 @@
 	bytes += (*i)->offset;
 	size = (*i)->data + bytes;
 
-	if((dir = malloc(sizeof(struct dir))) == NULL)
+	dir = malloc(sizeof(struct dir));
+	if(dir == NULL)
 		EXIT_UNSQUASH("squashfs_opendir: malloc failed!\n");
 
 	dir->dir_count = 0;
diff -urN squashfs-4.1/squashfs-tools/unsquash-2.c squashfs-4.1-20101223/squashfs-tools/unsquash-2.c
--- squashfs-4.1/squashfs-tools/unsquash-2.c	2010-08-25 19:26:08.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/unsquash-2.c	2010-10-24 02:11:48.000000000 +0100
@@ -205,8 +205,8 @@
 			i.fragment = inode->fragment;
 			i.offset = inode->offset;
 			i.blocks = inode->fragment == SQUASHFS_INVALID_FRAG ?
-				(inode->file_size + sBlk.s.block_size - 1) >>
-				sBlk.s.block_log : inode->file_size >>
+				(i.data + sBlk.s.block_size - 1) >>
+				sBlk.s.block_log : i.data >>
 				sBlk.s.block_log;
 			i.start = inode->start_block;
 			i.sparse = 0;
diff -urN squashfs-4.1/squashfs-tools/unsquash-3.c squashfs-4.1-20101223/squashfs-tools/unsquash-3.c
--- squashfs-4.1/squashfs-tools/unsquash-3.c	2010-08-25 19:26:23.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/unsquash-3.c	2010-12-16 04:22:00.000000000 +0000
@@ -39,8 +39,9 @@
 	if(sBlk.s.fragments == 0)
 		return TRUE;
 
-	if((fragment_table = malloc(sBlk.s.fragments *
-			sizeof(squashfs_fragment_entry_3))) == NULL)
+	fragment_table = malloc(sBlk.s.fragments *
+		sizeof(squashfs_fragment_entry_3));
+	if(fragment_table == NULL)
 		EXIT_UNSQUASH("read_fragment_table: failed to allocate "
 			"fragment table\n");
 
@@ -188,9 +189,9 @@
 			i.fragment = inode->fragment;
 			i.offset = inode->offset;
 			i.blocks = inode->fragment == SQUASHFS_INVALID_FRAG ?
-				(inode->file_size + sBlk.s.block_size - 1) >>
+				(i.data + sBlk.s.block_size - 1) >>
 				sBlk.s.block_log :
-				inode->file_size >> sBlk.s.block_log;
+				i.data >> sBlk.s.block_log;
 			i.start = inode->start_block;
 			i.sparse = 1;
 			i.block_ptr = block_ptr + sizeof(*inode);
@@ -298,7 +299,8 @@
 	bytes += (*i)->offset;
 	size = (*i)->data + bytes - 3;
 
-	if((dir = malloc(sizeof(struct dir))) == NULL)
+	dir = malloc(sizeof(struct dir));
+	if(dir == NULL)
 		EXIT_UNSQUASH("squashfs_opendir: malloc failed!\n");
 
 	dir->dir_count = 0;
diff -urN squashfs-4.1/squashfs-tools/unsquash-4.c squashfs-4.1-20101223/squashfs-tools/unsquash-4.c
--- squashfs-4.1/squashfs-tools/unsquash-4.c	2010-08-25 19:26:33.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/unsquash-4.c	2010-12-16 04:25:15.000000000 +0000
@@ -41,8 +41,9 @@
 	if(sBlk.s.fragments == 0)
 		return TRUE;
 
-	if((fragment_table = malloc(sBlk.s.fragments *
-			sizeof(squashfs_fragment_entry))) == NULL)
+	fragment_table = malloc(sBlk.s.fragments *
+		sizeof(squashfs_fragment_entry));
+	if(fragment_table == NULL)
 		EXIT_UNSQUASH("read_fragment_table: failed to allocate "
 			"fragment table\n");
 
@@ -143,9 +144,9 @@
 			i.fragment = inode->fragment;
 			i.offset = inode->offset;
 			i.blocks = inode->fragment == SQUASHFS_INVALID_FRAG ?
-				(inode->file_size + sBlk.s.block_size - 1) >>
+				(i.data + sBlk.s.block_size - 1) >>
 				sBlk.s.block_log :
-				inode->file_size >> sBlk.s.block_log;
+				i.data >> sBlk.s.block_log;
 			i.start = inode->start_block;
 			i.sparse = 0;
 			i.block_ptr = block_ptr + sizeof(*inode);
@@ -266,7 +267,8 @@
 	bytes += (*i)->offset;
 	size = (*i)->data + bytes - 3;
 
-	if((dir = malloc(sizeof(struct dir))) == NULL)
+	dir = malloc(sizeof(struct dir));
+	if(dir == NULL)
 		EXIT_UNSQUASH("squashfs_opendir: malloc failed!\n");
 
 	dir->dir_count = 0;
diff -urN squashfs-4.1/squashfs-tools/unsquashfs.c squashfs-4.1-20101223/squashfs-tools/unsquashfs.c
--- squashfs-4.1/squashfs-tools/unsquashfs.c	2010-09-19 22:44:38.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/unsquashfs.c	2010-12-20 03:12:02.000000000 +0000
@@ -143,7 +143,8 @@
 	if(queue == NULL)
 		EXIT_UNSQUASH("Out of memory in queue_init\n");
 
-	if((queue->data = malloc(sizeof(void *) * (size + 1))) == NULL)
+	queue->data = malloc(sizeof(void *) * (size + 1));
+	if(queue->data == NULL)
 		EXIT_UNSQUASH("Out of memory in queue_init\n");
 
 	queue->size = size + 1;
@@ -453,13 +454,15 @@
 		return 1;
 	}
 
-	if((user = getpwuid(inode->uid)) == NULL) {
+	user = getpwuid(inode->uid);
+	if(user == NULL) {
 		sprintf(dummy, "%d", inode->uid);
 		userstr = dummy;
 	} else
 		userstr = user->pw_name;
 		 
-	if((group = getgrgid(inode->gid)) == NULL) {
+	group = getgrgid(inode->gid);
+	if(group == NULL) {
 		sprintf(dummy2, "%d", inode->gid);
 		groupstr = dummy2;
 	} else
@@ -508,7 +511,8 @@
 	int hash = CALCULATE_HASH(start);
 	struct hash_table_entry *hash_table_entry;
 
-	if((hash_table_entry = malloc(sizeof(struct hash_table_entry))) == NULL)
+	hash_table_entry = malloc(sizeof(struct hash_table_entry));
+	if(hash_table_entry == NULL)
 		EXIT_UNSQUASH("Out of memory in add_entry\n");
 
 	hash_table_entry->start = start;
@@ -737,7 +741,7 @@
 int lseek_broken = FALSE;
 char *zero_data = NULL;
 
-int write_block(int file_fd, char *buffer, int size, int hole, int sparse)
+int write_block(int file_fd, char *buffer, int size, long long hole, int sparse)
 {
 	off_t off = hole;
 
@@ -797,12 +801,14 @@
 		return FALSE;
 	}
 
-	if((block_list = malloc(inode->blocks * sizeof(unsigned int))) == NULL)
+	block_list = malloc(inode->blocks * sizeof(unsigned int));
+	if(block_list == NULL)
 		EXIT_UNSQUASH("write_file: unable to malloc block list\n");
 
 	s_ops.read_block_list(block_list, inode->block_ptr, inode->blocks);
 
-	if((file = malloc(sizeof(struct squashfs_file))) == NULL)
+	file = malloc(sizeof(struct squashfs_file));
+	if(file == NULL)
 		EXIT_UNSQUASH("write_file: unable to malloc file\n");
 
 	/*
@@ -1069,7 +1075,8 @@
 	target = get_component(target, targname);
 
 	if(paths == NULL) {
-		if((paths = malloc(sizeof(struct pathname))) == NULL)
+		paths = malloc(sizeof(struct pathname));
+		if(paths == NULL)
 			EXIT_UNSQUASH("failed to allocate paths\n");
 
 		paths->names = 0;
@@ -1299,9 +1306,12 @@
 		print_filename(parent_name, i);
 
 	if(!lsonly && mkdir(parent_name, (mode_t) dir->mode) == -1 &&
-			(!force || errno != EEXIST))
-		ERROR("dir_scan: failed to open directory %s, because %s\n",
+			(!force || errno != EEXIST)) {
+		ERROR("dir_scan: failed to make directory %s, because %s\n",
 			parent_name, strerror(errno));
+		squashfs_closedir(dir);
+		return;
+	}
 
 	while(squashfs_readdir(dir, &name, &start_block, &offset, &type)) {
 		TRACE("dir_scan: name %s, start_block %d, offset %d, type %d\n",
@@ -1357,43 +1367,62 @@
 		sBlk.s.s_major == 4 ? "" : swap ? "big endian " :
 		"little endian ", sBlk.s.s_major, sBlk.s.s_minor, source);
 #endif
+
 	printf("Creation or last append time %s", mkfs_str ? mkfs_str :
 		"failed to get time\n");
 	printf("Filesystem size %.2f Kbytes (%.2f Mbytes)\n",
 		sBlk.s.bytes_used / 1024.0, sBlk.s.bytes_used /
 		(1024.0 * 1024.0));
+
 	if(sBlk.s.s_major == 4)
 		printf("Compression %s\n", comp->name);
+
 	printf("Block size %d\n", sBlk.s.block_size);
 	printf("Filesystem is %sexportable via NFS\n",
 		SQUASHFS_EXPORTABLE(sBlk.s.flags) ? "" : "not ");
-
 	printf("Inodes are %scompressed\n",
 		SQUASHFS_UNCOMPRESSED_INODES(sBlk.s.flags) ? "un" : "");
 	printf("Data is %scompressed\n",
 		SQUASHFS_UNCOMPRESSED_DATA(sBlk.s.flags) ? "un" : "");
-	if(sBlk.s.s_major > 1 && !SQUASHFS_NO_FRAGMENTS(sBlk.s.flags))
-		printf("Fragments are %scompressed\n",
-			SQUASHFS_UNCOMPRESSED_FRAGMENTS(sBlk.s.flags) ? "un" :
-			"");
-	printf("Check data is %spresent in the filesystem\n",
-		SQUASHFS_CHECK_DATA(sBlk.s.flags) ? "" : "not ");
+
 	if(sBlk.s.s_major > 1) {
-		printf("Fragments are %spresent in the filesystem\n",
-			SQUASHFS_NO_FRAGMENTS(sBlk.s.flags) ? "not " : "");
-		printf("Always_use_fragments option is %sspecified\n",
-			SQUASHFS_ALWAYS_FRAGMENTS(sBlk.s.flags) ? "" : "not ");
-	} else
-		printf("Fragments are not supported by the filesystem\n");
+		if(SQUASHFS_NO_FRAGMENTS(sBlk.s.flags))
+			printf("Fragments are not stored\n");
+		else {
+			printf("Fragments are %scompressed\n",
+				SQUASHFS_UNCOMPRESSED_FRAGMENTS(sBlk.s.flags) ?
+				"un" : "");
+			printf("Always_use_fragments option is %sspecified\n",
+				SQUASHFS_ALWAYS_FRAGMENTS(sBlk.s.flags) ? "" :
+				"not ");
+		}
+	}
+
+	if(sBlk.s.s_major == 4) {
+		if(SQUASHFS_NO_XATTRS(sBlk.s.flags))
+			printf("Xattrs are not stored\n");
+		else
+			printf("Xattrs are %scompressed\n",
+				SQUASHFS_UNCOMPRESSED_XATTRS(sBlk.s.flags) ?
+				"un" : "");
+	}
+
+	if(sBlk.s.s_major < 4)
+			printf("Check data is %spresent in the filesystem\n",
+				SQUASHFS_CHECK_DATA(sBlk.s.flags) ? "" :
+				"not ");
 
 	if(sBlk.s.s_major > 1)
 		printf("Duplicates are %sremoved\n",
 			SQUASHFS_DUPLICATES(sBlk.s.flags) ? "" : "not ");
 	else
 		printf("Duplicates are removed\n");
+
 	if(sBlk.s.s_major > 1)
 		printf("Number of fragments %d\n", sBlk.s.fragments);
+
 	printf("Number of inodes %d\n", sBlk.s.inodes);
+
 	if(sBlk.s.s_major == 4)
 		printf("Number of ids %d\n", sBlk.s.no_ids);
 	else {
@@ -1404,6 +1433,7 @@
 	TRACE("sBlk.s.inode_table_start 0x%llx\n", sBlk.s.inode_table_start);
 	TRACE("sBlk.s.directory_table_start 0x%llx\n",
 		sBlk.s.directory_table_start);
+
 	if(sBlk.s.s_major == 4) {
 		TRACE("sBlk.s.id_table_start 0x%llx\n", sBlk.s.id_table_start);
 		TRACE("sBlk.s.xattr_id_table_start 0x%llx\n",
@@ -1412,6 +1442,7 @@
 		TRACE("sBlk.uid_start 0x%llx\n", sBlk.uid_start);
 		TRACE("sBlk.guid_start 0x%llx\n", sBlk.guid_start);
 	}
+
 	if(sBlk.s.s_major > 1)
 		TRACE("sBlk.s.fragment_table_start 0x%llx\n\n",
 			sBlk.s.fragment_table_start);
@@ -1551,7 +1582,8 @@
 	FILE *fd;
 	char name[16384];
 
-	if((fd = fopen(filename, "r")) == NULL)
+	fd = fopen(filename, "r");
+	if(fd == NULL)
 		EXIT_UNSQUASH("Could not open %s, because %s\n", filename,
 			strerror(errno));
 
@@ -1604,7 +1636,7 @@
 	while(1) {
 		struct squashfs_file *file = queue_get(to_writer);
 		int file_fd;
-		int hole = 0;
+		long long hole = 0;
 		int failed = FALSE;
 		int error;
 
@@ -1798,7 +1830,8 @@
 #endif
 	}
 
-	if((thread = malloc((3 + processors) * sizeof(pthread_t))) == NULL)
+	thread = malloc((3 + processors) * sizeof(pthread_t));
+	if(thread == NULL)
 		EXIT_UNSQUASH("Out of memory allocating thread descriptors\n");
 	deflator_thread = &thread[3];
 
@@ -1903,7 +1936,7 @@
 
 
 #define VERSION() \
-	printf("unsquashfs version 4.1 (2010/09/19)\n");\
+	printf("unsquashfs version 4.1-CVS (2010/12/19)\n");\
 	printf("copyright (C) 2010 Phillip Lougher "\
 		"<phillip@lougher.demon.co.uk>\n\n");\
     	printf("This program is free software; you can redistribute it and/or"\
@@ -2081,7 +2114,7 @@
 			ERROR("\t-da[ta-queue] <size>\tSet data queue to "
 				"<size> Mbytes.  Default %d\n\t\t\t\tMbytes\n",
 				DATA_BUFFER_DEFAULT);
-			ERROR("\t-fr[ag-queue] <size>\tSet fagment queue to "
+			ERROR("\t-fr[ag-queue] <size>\tSet fragment queue to "
 				"<size> Mbytes.  Default %d\n\t\t\t\t Mbytes\n",
 				FRAGMENT_BUFFER_DEFAULT);
 			ERROR("\t-r[egex]\t\ttreat extract names as POSIX "
@@ -2126,16 +2159,20 @@
 	data_buffer_size <<= 20 - block_log;
 	initialise_threads(fragment_buffer_size, data_buffer_size);
 
-	if((fragment_data = malloc(block_size)) == NULL)
+	fragment_data = malloc(block_size);
+	if(fragment_data == NULL)
 		EXIT_UNSQUASH("failed to allocate fragment_data\n");
 
-	if((file_data = malloc(block_size)) == NULL)
+	file_data = malloc(block_size);
+	if(file_data == NULL)
 		EXIT_UNSQUASH("failed to allocate file_data");
 
-	if((data = malloc(block_size)) == NULL)
+	data = malloc(block_size);
+	if(data == NULL)
 		EXIT_UNSQUASH("failed to allocate data\n");
 
-	if((created_inode = malloc(sBlk.s.inodes * sizeof(char *))) == NULL)
+	created_inode = malloc(sBlk.s.inodes * sizeof(char *));
+	if(created_inode == NULL)
 		EXIT_UNSQUASH("failed to allocate created_inode\n");
 
 	memset(created_inode, 0, sBlk.s.inodes * sizeof(char *));
diff -urN squashfs-4.1/squashfs-tools/unsquashfs_xattr.c squashfs-4.1-20101223/squashfs-tools/unsquashfs_xattr.c
--- squashfs-4.1/squashfs-tools/unsquashfs_xattr.c	2010-08-25 18:11:22.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/unsquashfs_xattr.c	2010-11-12 04:52:46.000000000 +0000
@@ -25,7 +25,7 @@
 #include "unsquashfs.h"
 #include "xattr.h"
 
-#include <attr/xattr.h>
+#include <sys/xattr.h>
 
 extern int root_process;
 
diff -urN squashfs-4.1/squashfs-tools/xattr.c squashfs-4.1-20101223/squashfs-tools/xattr.c
--- squashfs-4.1/squashfs-tools/xattr.c	2010-08-24 02:37:37.000000000 +0100
+++ squashfs-4.1-20101223/squashfs-tools/xattr.c	2010-11-20 14:31:08.000000000 +0000
@@ -34,7 +34,7 @@
 #include <dirent.h>
 #include <string.h>
 #include <stdlib.h>
-#include <attr/xattr.h>
+#include <sys/xattr.h>
 
 #include "squashfs_fs.h"
 #include "global.h"
@@ -219,6 +219,10 @@
 			break;
 		}
 		xattr_list[i].vsize = vsize;
+
+		TRACE("read_xattrs_from_system: filename %s, xattr name %s,"
+			" vsize %d\n", filename, xattr_list[i].full_name,
+			xattr_list[i].vsize);
 	}
 	free(xattr_names);
 	*xattrs = xattr_list;
diff -urN squashfs-4.1/squashfs-tools/xz_wrapper.c squashfs-4.1-20101223/squashfs-tools/xz_wrapper.c
--- squashfs-4.1/squashfs-tools/xz_wrapper.c	2010-02-01 02:48:01.000000000 +0000
+++ squashfs-4.1-20101223/squashfs-tools/xz_wrapper.c	2010-12-08 02:51:08.000000000 +0000
@@ -17,69 +17,192 @@
  * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  *
  * xz_wrapper.c
+ *
+ * Support for XZ (LZMA2) compression using XZ Utils liblzma http://tukaani.org/xz/
  */
 
 #include <stdio.h>
 #include <string.h>
+#include <stdlib.h>
 #include <lzma.h>
 
-#define LZMA_PROPS_SIZE 5
-#define LZMA_UNCOMP_SIZE 8
-#define LZMA_HEADER_SIZE (LZMA_PROPS_SIZE + LZMA_UNCOMP_SIZE)
+#include "squashfs_fs.h"
+#include "compressor.h"
 
-#define LZMA_OPTIONS 5
 #define MEMLIMIT (32 * 1024 * 1024)
 
-int lzma_compress(void **dummy, void *dest, void *src,  int size,
-	int block_size, int *error)
-{
-	unsigned char *d = (unsigned char *) dest;
+static struct bcj {
+	char	 	*name;
+	lzma_vli	id;
+	int		selected;
+} bcj[] = {
+	{ "x86", LZMA_FILTER_X86, 0 },
+	{ "powerpc", LZMA_FILTER_POWERPC, 0 },
+	{ "ia64", LZMA_FILTER_IA64, 0 },
+	{ "arm", LZMA_FILTER_ARM, 0 },
+	{ "armthumb", LZMA_FILTER_ARMTHUMB, 0 },
+	{ "sparc", LZMA_FILTER_SPARC, 0 },
+	{ NULL, LZMA_VLI_UNKNOWN, 0 }
+};
+
+struct filter {
+	void		*buffer;
+	lzma_filter	filter[3];
+	size_t		length;
+};
+
+struct xz_stream {
+	struct filter	*filter;
+	int		filters;
 	lzma_options_lzma opt;
-	lzma_stream strm = LZMA_STREAM_INIT;
-	int res;
+};
 
-	lzma_lzma_preset(&opt, LZMA_OPTIONS);
-	opt.dict_size = block_size;
-	res = lzma_alone_encoder(&strm, &opt);
-	if(res != LZMA_OK) {
-		lzma_end(&strm);
+static int filter_count = 1;
+
+
+static int xz_options(char *argv[], int argc)
+{
+	int i;
+	char *name;
+
+	if(strcmp(argv[0], "-Xbcj") == 0) {
+		if(argc < 2) {
+			fprintf(stderr, "xz: -Xbcj missing filter\n");
+			goto failed;
+		}
+
+		name = argv[1];
+		while(name[0] != '\0') {
+			for(i = 0; bcj[i].name; i++) {
+				int n = strlen(bcj[i].name);
+				if((strncmp(name, bcj[i].name, n) == 0) &&
+						(name[n] == '\0' ||
+						 name[n] == ',')) {
+					if(bcj[i].selected == 0) {
+				 		bcj[i].selected = 1;
+						filter_count++;
+					}
+					name += name[n] == ',' ? n + 1 : n;
+					break;
+				}
+			}
+			if(bcj[i].name == NULL) {
+				fprintf(stderr, "xz: -Xbcj unrecognised filter\n");
+				goto failed;
+			}
+		}
+	
+		return 1;
+	}
+
+	return -1;
+	
+failed:
+	return -2;
+}
+		
+
+void xz_usage()
+{
+	fprintf(stderr, "\t  -Xbcj filter1,filter2,...,filterN\n");
+	fprintf(stderr, "\t\tCompress using filter1,filter2,...,filterN in");
+	fprintf(stderr, " turn\n\t\t(in addition to no filter), and choose");
+	fprintf(stderr, " the best compression.\n");
+	fprintf(stderr, "\t\tAvailable filters: x86, arm, armthumb,");
+	fprintf(stderr, " powerpc, sparc, ia64\n");
+}
+
+
+static int xz_init(void **strm, int block_size, int flags)
+{
+	int i, j, filters = flags ? filter_count : 1;
+	struct filter *filter = malloc(filters * sizeof(struct filter));
+	struct xz_stream *stream;
+
+	if(filter == NULL)
 		goto failed;
+
+	stream = *strm = malloc(sizeof(struct xz_stream));
+	if(stream == NULL)
+		goto failed2;
+
+	stream->filter = filter;
+	stream->filters = filters;
+
+	memset(filter, 0, filters * sizeof(struct filter));
+
+	filter[0].filter[0].id = LZMA_FILTER_LZMA2;
+	filter[0].filter[0].options = &stream->opt;
+	filter[0].filter[1].id = LZMA_VLI_UNKNOWN;
+
+	for(i = 0, j = 1; flags && bcj[i].name; i++) {
+		if(bcj[i].selected) {
+			filter[j].buffer = malloc(block_size);
+			if(filter[j].buffer == NULL)
+				goto failed3;
+			filter[j].filter[0].id = bcj[i].id;
+			filter[j].filter[1].id = LZMA_FILTER_LZMA2;
+			filter[j].filter[1].options = &stream->opt;
+			filter[j].filter[2].id = LZMA_VLI_UNKNOWN;
+			j++;
+		}
 	}
 
-	strm.next_out = dest;
-	strm.avail_out = block_size;
-	strm.next_in = src;
-	strm.avail_in = size;
+	return 0;
 
-	res = lzma_code(&strm, LZMA_FINISH);
-	lzma_end(&strm);
+failed3:
+	for(i = 1; i < filters; i++)
+		free(filter[i].buffer);
+	free(stream);
 
-	if(res == LZMA_STREAM_END) {
-		/*
-	 	 * Fill in the 8 byte little endian uncompressed size field in
-		 * the LZMA header.  8 bytes is excessively large for squashfs
-		 * but this is the standard LZMA header and which is expected by
-		 * the kernel code
-	 	 */
+failed2:
+	free(filter);
+
+failed:
+	return -1;
+}
 
-		d[LZMA_PROPS_SIZE] = size & 255;
-		d[LZMA_PROPS_SIZE + 1] = (size >> 8) & 255;
-		d[LZMA_PROPS_SIZE + 2] = (size >> 16) & 255;
-		d[LZMA_PROPS_SIZE + 3] = (size >> 24) & 255;
-		d[LZMA_PROPS_SIZE + 4] = 0;
-		d[LZMA_PROPS_SIZE + 5] = 0;
-		d[LZMA_PROPS_SIZE + 6] = 0;
-		d[LZMA_PROPS_SIZE + 7] = 0;
 
-		return (int) strm.total_out;
+static int xz_compress(void *strm, void *dest, void *src,  int size,
+	int block_size, int *error)
+{
+	int i;
+        lzma_ret res = 0;
+	struct xz_stream *stream = strm;
+	struct filter *selected = NULL;
+
+	stream->filter[0].buffer = dest;
+
+	for(i = 0; i < stream->filters; i++) {
+		struct filter *filter = &stream->filter[i];
+
+        	if(lzma_lzma_preset(&stream->opt, LZMA_PRESET_DEFAULT))
+                	goto failed;
+
+		stream->opt.dict_size = block_size;
+		filter->length = 0;
+		res = lzma_stream_buffer_encode(filter->filter,
+			LZMA_CHECK_CRC32, NULL, src, size, filter->buffer,
+			&filter->length, block_size);
+	
+		if(res == LZMA_OK) {
+			if(!selected || selected->length > filter->length)
+				selected = filter;
+		} else if(res != LZMA_BUF_ERROR)
+			goto failed;
 	}
 
-	if(res == LZMA_OK)
+	if(!selected)
 		/*
 	 	 * Output buffer overflow.  Return out of buffer space
 	 	 */
 		return 0;
 
+	if(selected->buffer != dest)
+		memcpy(dest, selected->buffer, selected->length);
+
+	return (int) selected->length;
+
 failed:
 	/*
 	 * All other errors return failure, with the compressor
@@ -90,49 +213,29 @@
 }
 
 
-int lzma_uncompress(void *dest, void *src, int size, int block_size,
+static int xz_uncompress(void *dest, void *src, int size, int block_size,
 	int *error)
 {
-	lzma_stream strm = LZMA_STREAM_INIT;
-	int uncompressed_size = 0, res;
-	unsigned char lzma_header[LZMA_HEADER_SIZE];
-
-	res = lzma_alone_decoder(&strm, MEMLIMIT);
-	if(res != LZMA_OK) {
-		lzma_end(&strm);
-		goto failed;
-	}
+	size_t src_pos = 0;
+	size_t dest_pos = 0;
+	uint64_t memlimit = MEMLIMIT;
 
-	memcpy(lzma_header, src, LZMA_HEADER_SIZE);
-	uncompressed_size = lzma_header[LZMA_PROPS_SIZE] |
-		(lzma_header[LZMA_PROPS_SIZE + 1] << 8) |
-		(lzma_header[LZMA_PROPS_SIZE + 2] << 16) |
-		(lzma_header[LZMA_PROPS_SIZE + 3] << 24);
-	memset(lzma_header + LZMA_PROPS_SIZE, 255, LZMA_UNCOMP_SIZE);
-
-	strm.next_out = dest;
-	strm.avail_out = block_size;
-	strm.next_in = lzma_header;
-	strm.avail_in = LZMA_HEADER_SIZE;
+	lzma_ret res = lzma_stream_buffer_decode(&memlimit, 0, NULL,
+			src, &src_pos, size, dest, &dest_pos, block_size);
 
-	res = lzma_code(&strm, LZMA_RUN);
-
-	if(res != LZMA_OK || strm.avail_in != 0) {
-		lzma_end(&strm);
-		goto failed;
-	}
-
-	strm.next_in = src + LZMA_HEADER_SIZE;
-	strm.avail_in = size - LZMA_HEADER_SIZE;
+	*error = res;
+	return res == LZMA_OK && size == (int) src_pos ? (int) dest_pos : -1;
+}
 
-	res = lzma_code(&strm, LZMA_FINISH);
-	lzma_end(&strm);
 
-	if(res == LZMA_STREAM_END || (res == LZMA_OK &&
-		strm.total_out >= uncompressed_size && strm.avail_in == 0))
-		return uncompressed_size;
+struct compressor xz_comp_ops = {
+	.init = xz_init,
+	.compress = xz_compress,
+	.uncompress = xz_uncompress,
+	.options = xz_options,
+	.usage = xz_usage,
+	.id = XZ_COMPRESSION,
+	.name = "xz",
+	.supported = 1
+};
 
-failed:
-	*error = res;
-	return -1;
-}
